//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 10.0
//
//  This file is intended to be used with the HDevelopTemplate or
//  HDevelopTemplateWPF projects located under %HALCONEXAMPLES%\c#

using System;
using HalconDotNet;

namespace DALSA.SaperaLT.Demos.NET.CSharp.MultiBoardSyncGrabDemo
{


    public partial class HDevelopExport
    {
        public HTuple hv_ExpDefaultWinHandle;

        public void dev_open_window_fit_image(HObject ho_Image, HTuple hv_Row, HTuple hv_Column,
         HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
        {



            // Local control variables 

            HTuple hv_MinWidth = new HTuple(), hv_MaxWidth = new HTuple();
            HTuple hv_MinHeight = new HTuple(), hv_MaxHeight = new HTuple();
            HTuple hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
            HTuple hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

            // Initialize local and output iconic variables 

            //This procedure opens a new graphics window and adjusts the size
            //such that it fits into the limits specified by WidthLimit
            //and HeightLimit, but also maintains the correct image aspect ratio.
            //
            //If it is impossible to match the minimum and maximum extent requirements
            //at the same time (f.e. if the image is very long but narrow),
            //the maximum value gets a higher priority,
            //
            //Parse input tuple WidthLimit
            if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
            {
                hv_MinWidth = 500;
                hv_MaxWidth = 800;
            }
            else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
                1))) != 0)
            {
                hv_MinWidth = 0;
                hv_MaxWidth = hv_WidthLimit.Clone();
            }
            else
            {
                hv_MinWidth = hv_WidthLimit[0];
                hv_MaxWidth = hv_WidthLimit[1];
            }
            //Parse input tuple HeightLimit
            if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
                new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
            {
                hv_MinHeight = 400;
                hv_MaxHeight = 600;
            }
            else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
                1))) != 0)
            {
                hv_MinHeight = 0;
                hv_MaxHeight = hv_HeightLimit.Clone();
            }
            else
            {
                hv_MinHeight = hv_HeightLimit[0];
                hv_MaxHeight = hv_HeightLimit[1];
            }
            //
            //Test, if window size has to be changed.
            hv_ResizeFactor = 1;
            HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
            //First, expand window to the minimum extents (if necessary).
            if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
                hv_ImageHeight)))) != 0)
            {
                hv_ResizeFactor = (((((hv_MinWidth.TupleReal()) / hv_ImageWidth)).TupleConcat(
                    (hv_MinHeight.TupleReal()) / hv_ImageHeight))).TupleMax();
            }
            hv_TempWidth = hv_ImageWidth * hv_ResizeFactor;
            hv_TempHeight = hv_ImageHeight * hv_ResizeFactor;
            //Then, shrink window to maximum extents (if necessary).
            if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
                hv_TempHeight)))) != 0)
            {
                hv_ResizeFactor = hv_ResizeFactor * ((((((hv_MaxWidth.TupleReal()) / hv_TempWidth)).TupleConcat(
                    (hv_MaxHeight.TupleReal()) / hv_TempHeight))).TupleMin());
            }
            hv_WindowWidth = hv_ImageWidth * hv_ResizeFactor;
            hv_WindowHeight = hv_ImageHeight * hv_ResizeFactor;
            //Resize window
            HOperatorSet.SetWindowAttr("background_color", "black");
            HOperatorSet.OpenWindow(hv_Row, hv_Column, hv_WindowWidth, hv_WindowHeight, 0, "", "", out hv_WindowHandle);
            HDevWindowStack.Push(hv_WindowHandle);
            if (HDevWindowStack.IsOpen())
            {
                HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight - 1, hv_ImageWidth - 1);
            }

            return;
        }


        //local procedure
        public void get_defect_lab(HObject ho_Image, out HObject ho_DefectRegion, HTuple hv_boxNumber,
         HTuple hv_boxWidth, HTuple hv_boxHeight, HTuple hv_boxBenginX, HTuple hv_medianKernal,
         HTuple hv_dynThresh, HTuple hv_defectArea, out HTuple hv_result, out HTuple hv_tupleL,
         out HTuple hv_tupleA, out HTuple hv_tupleB, out HTuple hv_defectNumber, out HTuple hv_tupleDefectX,
         out HTuple hv_tupleDefectY, out HTuple hv_tupleDefectRadius)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];
            long SP_O = 0;

            // Local iconic variables 

            HObject ho_GrayImage, ho_Region, ho_ConnectedRegions;
            HObject ho_SelectedRegions, ho_SortedRegions = null, ho_ObjectSelected1 = null;
            HObject ho_ObjectSelected2 = null, ho_ClothRegion, ho_Rectangle = null;
            HObject ho_ImageReduced = null, ho_ImageMedian = null, ho_Region1 = null;
            HObject ho_ImageMedianReduced = null, ho_ImageR = null, ho_ImageG = null;
            HObject ho_ImageB = null, ho_ImageL = null, ho_ImageA = null;
            HObject ho_ClothRegionImage = null, ho_ImageMedian1 = null;
            HObject ho_Region2 = null, ho_ClothRegionErosion = null, ho_RegionIntersection = null;
            HObject ho_ConnectedRegions1 = null, ho_SelectedRegions1 = null;
            HObject ho_RegionDilation = null, ho_ConnectedRegions2 = null;


            // Local control variables 

            HTuple hv_Width, hv_Height, hv_Number, hv_Row11 = new HTuple();
            HTuple hv_Column11 = new HTuple(), hv_Row21 = new HTuple();
            HTuple hv_Column21 = new HTuple(), hv_Row12 = new HTuple();
            HTuple hv_Column12 = new HTuple(), hv_Row22 = new HTuple();
            HTuple hv_Column22 = new HTuple(), hv_Convexity1 = new HTuple();
            HTuple hv_Convexity2 = new HTuple(), hv_boxDistance = new HTuple();
            HTuple hv_boxBenginY = new HTuple(), hv_tupleDeviationL = new HTuple();
            HTuple hv_tupleDeviationA = new HTuple(), hv_tupleDeviationB = new HTuple();
            HTuple hv_i = new HTuple(), hv_MeanL = new HTuple(), hv_DeviationL = new HTuple();
            HTuple hv_MeanA = new HTuple(), hv_DeviationA = new HTuple();
            HTuple hv_MeanB = new HTuple(), hv_DeviationB = new HTuple();
            HTuple hv_Area = new HTuple(), hv_Row = new HTuple(), hv_Column = new HTuple();
            HTuple hv_Area1 = new HTuple();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_DefectRegion);
            HOperatorSet.GenEmptyObj(out ho_GrayImage);
            HOperatorSet.GenEmptyObj(out ho_Region);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
            HOperatorSet.GenEmptyObj(out ho_SortedRegions);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected1);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected2);
            HOperatorSet.GenEmptyObj(out ho_ClothRegion);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageMedian);
            HOperatorSet.GenEmptyObj(out ho_Region1);
            HOperatorSet.GenEmptyObj(out ho_ImageMedianReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            HOperatorSet.GenEmptyObj(out ho_ImageL);
            HOperatorSet.GenEmptyObj(out ho_ImageA);
            HOperatorSet.GenEmptyObj(out ho_ClothRegionImage);
            HOperatorSet.GenEmptyObj(out ho_ImageMedian1);
            HOperatorSet.GenEmptyObj(out ho_Region2);
            HOperatorSet.GenEmptyObj(out ho_ClothRegionErosion);
            HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions2);

            hv_tupleL = new HTuple();
            hv_tupleA = new HTuple();
            hv_tupleB = new HTuple();
            hv_defectNumber = new HTuple();
            hv_tupleDefectX = new HTuple();
            hv_tupleDefectY = new HTuple();
            hv_tupleDefectRadius = new HTuple();
            hv_result = 0;
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            ho_GrayImage.Dispose();
            HOperatorSet.Rgb1ToGray(ho_Image, out ho_GrayImage);
            ho_Region.Dispose();
            HOperatorSet.BinThreshold(ho_GrayImage, out ho_Region);
            //binary_threshold (GrayImage, Region, 'max_separability', 'dark', UsedThreshold)
            ho_ConnectedRegions.Dispose();
            HOperatorSet.Connection(ho_Region, out ho_ConnectedRegions);
            ho_SelectedRegions.Dispose();
            HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "width",
                "and", hv_Width / 2, hv_Width - 200);
            HOperatorSet.CountObj(ho_SelectedRegions, out hv_Number);
            //if (Number=0)
            //    binary_threshold (GrayImage, Region, 'max_separability', 'light', UsedThreshold)
            //connection (Region, ConnectedRegions)
            //select_shape (ConnectedRegions, SelectedRegions, 'width', 'and', Width/2, Width-400)
            //count_obj (SelectedRegions, Number)
            //endif
            OTemp[SP_O] = ho_SelectedRegions.CopyObj(1, -1);
            SP_O++;
            ho_SelectedRegions.Dispose();
            HOperatorSet.FillUp(OTemp[SP_O - 1], out ho_SelectedRegions);
            OTemp[SP_O - 1].Dispose();
            SP_O = 0;
            if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
            {
                //未找到布匹
                hv_result = 1;
            }
            else if ((int)(new HTuple(hv_Number.TupleGreater(1))) != 0)
            {
                ho_SortedRegions.Dispose();
                HOperatorSet.SortRegion(ho_SelectedRegions, out ho_SortedRegions, "first_point",
                    "true", "row");
                ho_ObjectSelected1.Dispose();
                HOperatorSet.SelectObj(ho_SortedRegions, out ho_ObjectSelected1, 1);
                ho_ObjectSelected2.Dispose();
                HOperatorSet.SelectObj(ho_SortedRegions, out ho_ObjectSelected2, 2);
                HOperatorSet.SmallestRectangle1(ho_ObjectSelected1, out hv_Row11, out hv_Column11,
                    out hv_Row21, out hv_Column21);
                HOperatorSet.SmallestRectangle1(ho_ObjectSelected2, out hv_Row12, out hv_Column12,
                    out hv_Row22, out hv_Column22);
                HOperatorSet.Convexity(ho_ObjectSelected1, out hv_Convexity1);
                HOperatorSet.Convexity(ho_ObjectSelected2, out hv_Convexity2);
                if ((int)((new HTuple((new HTuple(hv_Column11.TupleLess(2))).TupleAnd(new HTuple(hv_Column22.TupleGreater(
                    hv_Height - 2))))).TupleAnd((new HTuple(hv_Convexity1.TupleLess(0.97))).TupleOr(
                    new HTuple(hv_Convexity2.TupleLess(0.97))))) != 0)
                {
                    //接缝布匹
                    hv_result = 2;
                }
                else
                {
                    //布匹有长瑕疵
                    hv_result = 0;
                    ho_DefectRegion.Dispose();
                    HOperatorSet.SelectShape(ho_SelectedRegions, out ho_DefectRegion, "height",
                        "and", 1, hv_Height / 3);
                }
            }
            ho_ClothRegion.Dispose();
            HOperatorSet.FillUp(ho_SelectedRegions, out ho_ClothRegion);
            if ((int)(new HTuple(hv_result.TupleEqual(0))) != 0)
            {
                //色差检测
                //boxDistance表示两个框间距
                hv_boxDistance = ((hv_Width - (hv_boxNumber * hv_boxWidth)) - (hv_boxBenginX * 2)) / (hv_boxNumber - 1);
                //，boxBenginY框起始y坐标
                hv_boxBenginY = (hv_Height - hv_boxHeight) / 2;
                hv_tupleDeviationL = new HTuple();
                hv_tupleDeviationA = new HTuple();
                hv_tupleDeviationB = new HTuple();
                //gen_empty_obj (Boxs)
                for (hv_i = 0; hv_i.Continue(hv_boxNumber - 1, 1); hv_i = hv_i.TupleAdd(1))
                {
                    ho_Rectangle.Dispose();
                    HOperatorSet.GenRectangle1(out ho_Rectangle, hv_boxBenginY, hv_boxBenginX + (hv_i * (hv_boxWidth + hv_boxDistance)),
                        hv_boxBenginY + hv_boxHeight, (hv_boxBenginX + (hv_i * (hv_boxWidth + hv_boxDistance))) + hv_boxWidth);
                    ho_ImageReduced.Dispose();
                    HOperatorSet.ReduceDomain(ho_Image, ho_Rectangle, out ho_ImageReduced);
                    ho_ImageMedian.Dispose();
                    HOperatorSet.MedianImage(ho_ImageReduced, out ho_ImageMedian, "circle", hv_medianKernal * 0.5,
                        "mirrored");
                    ho_Region1.Dispose();
                    HOperatorSet.VarThreshold(ho_ImageMedian, out ho_Region1, 25, 25, 0.2, 2,
                        "equal");
                    ho_ImageMedianReduced.Dispose();
                    HOperatorSet.ReduceDomain(ho_ImageMedian, ho_Region1, out ho_ImageMedianReduced
                        );
                    ho_ImageR.Dispose();
                    ho_ImageG.Dispose();
                    ho_ImageB.Dispose();
                    HOperatorSet.Decompose3(ho_ImageMedianReduced, out ho_ImageR, out ho_ImageG,
                        out ho_ImageB);
                    OTemp[SP_O] = ho_ImageB.CopyObj(1, -1);
                    SP_O++;
                    ho_ImageL.Dispose();
                    ho_ImageA.Dispose();
                    ho_ImageB.Dispose();
                    HOperatorSet.TransFromRgb(ho_ImageR, ho_ImageG, OTemp[SP_O - 1], out ho_ImageL,
                        out ho_ImageA, out ho_ImageB, "cielab");
                    OTemp[SP_O - 1].Dispose();
                    SP_O = 0;
                    HOperatorSet.Intensity(ho_Rectangle, ho_ImageL, out hv_MeanL, out hv_DeviationL);
                    HOperatorSet.Intensity(ho_Rectangle, ho_ImageA, out hv_MeanA, out hv_DeviationA);
                    HOperatorSet.Intensity(ho_Rectangle, ho_ImageB, out hv_MeanB, out hv_DeviationB);
                    hv_tupleL[hv_i] = hv_MeanL;
                    hv_tupleA[hv_i] = hv_MeanA;
                    hv_tupleB[hv_i] = hv_MeanB;
                    hv_tupleDeviationL[hv_i] = hv_DeviationL;
                    hv_tupleDeviationA[hv_i] = hv_DeviationA;
                    hv_tupleDeviationB[hv_i] = hv_DeviationB;
                }

            }
            if ((int)(new HTuple(hv_result.TupleEqual(0))) != 0)
            {
                //瑕疵检测
                ho_ClothRegionImage.Dispose();
                HOperatorSet.ReduceDomain(ho_GrayImage, ho_ClothRegion, out ho_ClothRegionImage
                    );
                ho_ImageMedian1.Dispose();
                HOperatorSet.MedianImage(ho_ClothRegionImage, out ho_ImageMedian1, "circle",
                    5, "mirrored");
                ho_Region2.Dispose();
                HOperatorSet.VarThreshold(ho_ImageMedian1, out ho_Region2, 10, 100, 0.2, hv_dynThresh,
                    "not_equal");
                ho_ClothRegionErosion.Dispose();
                HOperatorSet.ErosionCircle(ho_Region2, out ho_ClothRegionErosion, 7);
                ho_RegionIntersection.Dispose();
                HOperatorSet.Intersection(ho_Region2, ho_ClothRegionErosion, out ho_RegionIntersection
                    );
                ho_ConnectedRegions1.Dispose();
                HOperatorSet.Connection(ho_RegionIntersection, out ho_ConnectedRegions1);
                ho_SelectedRegions1.Dispose();
                HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "area",
                    "and", hv_defectArea, 99999);
                HOperatorSet.AreaCenter(ho_SelectedRegions1, out hv_Area, out hv_Row, out hv_Column);
                if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                {
                    hv_result = 3;
                    OTemp[SP_O] = ho_DefectRegion.CopyObj(1, -1);
                    SP_O++;
                    ho_DefectRegion.Dispose();
                    HOperatorSet.Union2(OTemp[SP_O - 1], ho_SelectedRegions1, out ho_DefectRegion
                        );
                    OTemp[SP_O - 1].Dispose();
                    SP_O = 0;
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationCircle(ho_DefectRegion, out ho_RegionDilation, 5);
                    ho_ConnectedRegions2.Dispose();
                    HOperatorSet.Connection(ho_RegionDilation, out ho_ConnectedRegions2);
                    HOperatorSet.AreaCenter(ho_ConnectedRegions2, out hv_Area1, out hv_tupleDefectY,
                        out hv_tupleDefectX);
                    HOperatorSet.SmallestCircle(ho_ConnectedRegions2, out hv_tupleDefectY, out hv_tupleDefectX,
                        out hv_tupleDefectRadius);
                    HOperatorSet.CountObj(ho_ConnectedRegions2, out hv_defectNumber);
                }

            }


            ho_GrayImage.Dispose();
            ho_Region.Dispose();
            ho_ConnectedRegions.Dispose();
            ho_SelectedRegions.Dispose();
            ho_SortedRegions.Dispose();
            ho_ObjectSelected1.Dispose();
            ho_ObjectSelected2.Dispose();
            ho_ClothRegion.Dispose();
            ho_Rectangle.Dispose();
            ho_ImageReduced.Dispose();
            ho_ImageMedian.Dispose();
            ho_Region1.Dispose();
            ho_ImageMedianReduced.Dispose();
            ho_ImageR.Dispose();
            ho_ImageG.Dispose();
            ho_ImageB.Dispose();
            ho_ImageL.Dispose();
            ho_ImageA.Dispose();
            ho_ClothRegionImage.Dispose();
            ho_ImageMedian1.Dispose();
            ho_Region2.Dispose();
            ho_ClothRegionErosion.Dispose();
            ho_RegionIntersection.Dispose();
            ho_ConnectedRegions1.Dispose();
            ho_SelectedRegions1.Dispose();
            ho_RegionDilation.Dispose();
            ho_ConnectedRegions2.Dispose();

            return;
        }


        public void disp_message1(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
          HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_GenParamName = null, hv_GenParamValue = null;
            HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
            HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
            HTuple hv_CoordSystem_COPY_INP_TMP = hv_CoordSystem.Clone();
            HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();

            // Initialize local and output iconic variables 
            //This procedure displays text in a graphics window.
            //
            //Input parameters:
            //WindowHandle: The WindowHandle of the graphics window, where
            //   the message should be displayed
            //String: A tuple of strings containing the text message to be displayed
            //CoordSystem: If set to 'window', the text position is given
            //   with respect to the window coordinate system.
            //   If set to 'image', image coordinates are used.
            //   (This may be useful in zoomed images.)
            //Row: The row coordinate of the desired text position
            //   A tuple of values is allowed to display text at different
            //   positions.
            //Column: The column coordinate of the desired text position
            //   A tuple of values is allowed to display text at different
            //   positions.
            //Color: defines the color of the text as string.
            //   If set to [], '' or 'auto' the currently set color is used.
            //   If a tuple of strings is passed, the colors are used cyclically...
            //   - if |Row| == |Column| == 1: for each new textline
            //   = else for each text position.
            //Box: If Box[0] is set to 'true', the text is written within an orange box.
            //     If set to' false', no box is displayed.
            //     If set to a color string (e.g. 'white', '#FF00CC', etc.),
            //       the text is written in a box of that color.
            //     An optional second value for Box (Box[1]) controls if a shadow is displayed:
            //       'true' -> display a shadow in a default color
            //       'false' -> display no shadow
            //       otherwise -> use given string as color string for the shadow color
            //
            //It is possible to display multiple text strings in a single call.
            //In this case, some restrictions apply:
            //- Multiple text positions can be defined by specifying a tuple
            //  with multiple Row and/or Column coordinates, i.e.:
            //  - |Row| == n, |Column| == n
            //  - |Row| == n, |Column| == 1
            //  - |Row| == 1, |Column| == n
            //- If |Row| == |Column| == 1,
            //  each element of String is display in a new textline.
            //- If multiple positions or specified, the number of Strings
            //  must match the number of positions, i.e.:
            //  - Either |String| == n (each string is displayed at the
            //                          corresponding position),
            //  - or     |String| == 1 (The string is displayed n times).
            //
            //
            //Convert the parameters for disp_text.
            if ((int)((new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(new HTuple())))) != 0)
            {

                return;
            }
            if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Row_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Column_COPY_INP_TMP = 12;
            }
            //
            //Convert the parameter Box to generic parameters.
            hv_GenParamName = new HTuple();
            hv_GenParamValue = new HTuple();
            if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(0))) != 0)
            {
                if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleEqual("false"))) != 0)
                {
                    //Display no box
                    hv_GenParamName = hv_GenParamName.TupleConcat("box");
                    hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
                }
                else if ((int)(new HTuple(((hv_Box.TupleSelect(0))).TupleNotEqual("true"))) != 0)
                {
                    //Set a color other than the default.
                    hv_GenParamName = hv_GenParamName.TupleConcat("box_color");
                    hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(0));
                }
            }
            if ((int)(new HTuple((new HTuple(hv_Box.TupleLength())).TupleGreater(1))) != 0)
            {
                if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleEqual("false"))) != 0)
                {
                    //Display no shadow.
                    hv_GenParamName = hv_GenParamName.TupleConcat("shadow");
                    hv_GenParamValue = hv_GenParamValue.TupleConcat("false");
                }
                else if ((int)(new HTuple(((hv_Box.TupleSelect(1))).TupleNotEqual("true"))) != 0)
                {
                    //Set a shadow color other than the default.
                    hv_GenParamName = hv_GenParamName.TupleConcat("shadow_color");
                    hv_GenParamValue = hv_GenParamValue.TupleConcat(hv_Box.TupleSelect(1));
                }
            }
            //Restore default CoordSystem behavior.
            if ((int)(new HTuple(hv_CoordSystem_COPY_INP_TMP.TupleNotEqual("window"))) != 0)
            {
                hv_CoordSystem_COPY_INP_TMP = "image";
            }
            //
            if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(""))) != 0)
            {
                //disp_text does not accept an empty string for Color.
                hv_Color_COPY_INP_TMP = new HTuple();
            }
            //
            HOperatorSet.DispText(hv_WindowHandle, hv_String, hv_CoordSystem_COPY_INP_TMP,
                hv_Row_COPY_INP_TMP, hv_Column_COPY_INP_TMP, hv_Color_COPY_INP_TMP, hv_GenParamName,
                hv_GenParamValue);

            return;
        }

        public void disp_message(HTuple hv_WindowHandle, HTuple hv_String, HTuple hv_CoordSystem,
        HTuple hv_Row, HTuple hv_Column, HTuple hv_Color, HTuple hv_Box)
        {


            // Local control variables 

            HTuple hv_Red, hv_Green, hv_Blue, hv_Row1Part;
            HTuple hv_Column1Part, hv_Row2Part, hv_Column2Part, hv_RowWin;
            HTuple hv_ColumnWin, hv_WidthWin = new HTuple(), hv_HeightWin;
            HTuple hv_MaxAscent, hv_MaxDescent, hv_MaxWidth, hv_MaxHeight;
            HTuple hv_R1 = new HTuple(), hv_C1 = new HTuple(), hv_FactorRow = new HTuple();
            HTuple hv_FactorColumn = new HTuple(), hv_Width = new HTuple();
            HTuple hv_Index = new HTuple(), hv_Ascent = new HTuple(), hv_Descent = new HTuple();
            HTuple hv_W = new HTuple(), hv_H = new HTuple(), hv_FrameHeight = new HTuple();
            HTuple hv_FrameWidth = new HTuple(), hv_R2 = new HTuple();
            HTuple hv_C2 = new HTuple(), hv_DrawMode = new HTuple(), hv_Exception = new HTuple();
            HTuple hv_CurrentColor = new HTuple();

            HTuple hv_Color_COPY_INP_TMP = hv_Color.Clone();
            HTuple hv_Column_COPY_INP_TMP = hv_Column.Clone();
            HTuple hv_Row_COPY_INP_TMP = hv_Row.Clone();
            HTuple hv_String_COPY_INP_TMP = hv_String.Clone();

            // Initialize local and output iconic variables 

            //This procedure displays text in a graphics window.
            //
            //Input parameters:
            //WindowHandle: The WindowHandle of the graphics window, where
            //   the message should be displayed
            //String: A tuple of strings containing the text message to be displayed
            //CoordSystem: If set to 'window', the text position is given
            //   with respect to the window coordinate system.
            //   If set to 'image', image coordinates are used.
            //   (This may be useful in zoomed images.)
            //Row: The row coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Column: The column coordinate of the desired text position
            //   If set to -1, a default value of 12 is used.
            //Color: defines the color of the text as string.
            //   If set to [], '' or 'auto' the currently set color is used.
            //   If a tuple of strings is passed, the colors are used cyclically
            //   for each new textline.
            //Box: If set to 'true', the text is written within a white box.
            //
            //prepare window
            hv_ExpDefaultWinHandle = hv_WindowHandle;
            HOperatorSet.GetRgb(hv_ExpDefaultWinHandle, out hv_Red, out hv_Green, out hv_Blue);
            HOperatorSet.GetPart(hv_ExpDefaultWinHandle, out hv_Row1Part, out hv_Column1Part,
                out hv_Row2Part, out hv_Column2Part);
            HOperatorSet.GetWindowExtents(hv_ExpDefaultWinHandle, out hv_RowWin, out hv_ColumnWin,
                out hv_WidthWin, out hv_HeightWin);
            HOperatorSet.SetPart(hv_ExpDefaultWinHandle, 0, 0, hv_HeightWin - 1, hv_WidthWin - 1);
            //
            //default settings
            if ((int)(new HTuple(hv_Row_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Row_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Column_COPY_INP_TMP.TupleEqual(-1))) != 0)
            {
                hv_Column_COPY_INP_TMP = 12;
            }
            if ((int)(new HTuple(hv_Color_COPY_INP_TMP.TupleEqual(new HTuple()))) != 0)
            {
                hv_Color_COPY_INP_TMP = "";
            }
            //
            hv_String_COPY_INP_TMP = ((("" + hv_String_COPY_INP_TMP) + "")).TupleSplit("\n");
            //
            //Estimate extentions of text depending on font size.
            HOperatorSet.GetFontExtents(hv_ExpDefaultWinHandle, out hv_MaxAscent, out hv_MaxDescent,
                out hv_MaxWidth, out hv_MaxHeight);
            if ((int)(new HTuple(hv_CoordSystem.TupleEqual("window"))) != 0)
            {
                hv_R1 = hv_Row_COPY_INP_TMP.Clone();
                hv_C1 = hv_Column_COPY_INP_TMP.Clone();
            }
            else
            {
                //transform image to window coordinates
                hv_FactorRow = (1.0 * hv_HeightWin) / ((hv_Row2Part - hv_Row1Part) + 1);
                hv_FactorColumn = (1.0 * hv_WidthWin) / ((hv_Column2Part - hv_Column1Part) + 1);
                hv_R1 = ((hv_Row_COPY_INP_TMP - hv_Row1Part) + 0.5) * hv_FactorRow;
                hv_C1 = ((hv_Column_COPY_INP_TMP - hv_Column1Part) + 0.5) * hv_FactorColumn;
            }
            //
            //display text box depending on text size
            if ((int)(new HTuple(hv_Box.TupleEqual("true"))) != 0)
            {
                //calculate box extents
                hv_String_COPY_INP_TMP = (" " + hv_String_COPY_INP_TMP) + " ";
                hv_Width = new HTuple();
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    HOperatorSet.GetStringExtents(hv_ExpDefaultWinHandle, hv_String_COPY_INP_TMP.TupleSelect(
                        hv_Index), out hv_Ascent, out hv_Descent, out hv_W, out hv_H);
                    hv_Width = hv_Width.TupleConcat(hv_W);
                }
                hv_FrameHeight = hv_MaxHeight * (new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                    ));
                hv_FrameWidth = (((new HTuple(0)).TupleConcat(hv_Width))).TupleMax();
                hv_R2 = hv_R1 + hv_FrameHeight;
                hv_C2 = hv_C1 + hv_FrameWidth;
                //display rectangles
                HOperatorSet.GetDraw(hv_ExpDefaultWinHandle, out hv_DrawMode);
                HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "fill");
                HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "light gray");
                HOperatorSet.DispRectangle1(hv_ExpDefaultWinHandle, hv_R1 + 3, hv_C1 + 3, hv_R2 + 3,
                    hv_C2 + 3);
                HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "white");
                HOperatorSet.DispRectangle1(hv_ExpDefaultWinHandle, hv_R1, hv_C1, hv_R2, hv_C2);
                HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, hv_DrawMode);
            }
            else if ((int)(new HTuple(hv_Box.TupleNotEqual("false"))) != 0)
            {
                hv_Exception = "Wrong value of control parameter Box";
                throw new HalconException(hv_Exception);
            }
            //Write text.
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_String_COPY_INP_TMP.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_CurrentColor = hv_Color_COPY_INP_TMP.TupleSelect(hv_Index % (new HTuple(hv_Color_COPY_INP_TMP.TupleLength()
                    )));
                if ((int)((new HTuple(hv_CurrentColor.TupleNotEqual(""))).TupleAnd(new HTuple(hv_CurrentColor.TupleNotEqual(
                    "auto")))) != 0)
                {
                    HOperatorSet.SetColor(hv_ExpDefaultWinHandle, hv_CurrentColor);
                }
                else
                {
                    HOperatorSet.SetRgb(hv_ExpDefaultWinHandle, hv_Red, hv_Green, hv_Blue);
                }
                hv_Row_COPY_INP_TMP = hv_R1 + (hv_MaxHeight * hv_Index);
                HOperatorSet.SetTposition(hv_ExpDefaultWinHandle, hv_Row_COPY_INP_TMP, hv_C1);
                HOperatorSet.WriteString(hv_ExpDefaultWinHandle, hv_String_COPY_INP_TMP.TupleSelect(
                    hv_Index));
            }
            //reset changed window settings
            HOperatorSet.SetRgb(hv_ExpDefaultWinHandle, hv_Red, hv_Green, hv_Blue);
            HOperatorSet.SetPart(hv_ExpDefaultWinHandle, hv_Row1Part, hv_Column1Part, hv_Row2Part,
                hv_Column2Part);

            return;
        }



        // Chapter: Graphics / Text
        // Short Description: Set font independent of OS 
        public void set_display_font(HTuple hv_WindowHandle, HTuple hv_Size, HTuple hv_Font,
            HTuple hv_Bold, HTuple hv_Slant)
        {



            // Local iconic variables 

            // Local control variables 

            HTuple hv_OS = null, hv_Fonts = new HTuple();
            HTuple hv_Style = null, hv_Exception = new HTuple(), hv_AvailableFonts = null;
            HTuple hv_Fdx = null, hv_Indices = new HTuple();
            HTuple hv_Font_COPY_INP_TMP = hv_Font.Clone();
            HTuple hv_Size_COPY_INP_TMP = hv_Size.Clone();

            // Initialize local and output iconic variables 
            //This procedure sets the text font of the current window with
            //the specified attributes.
            //
            //Input parameters:
            //WindowHandle: The graphics window for which the font will be set
            //Size: The font size. If Size=-1, the default of 16 is used.
            //Bold: If set to 'true', a bold font is used
            //Slant: If set to 'true', a slanted font is used
            //
            HOperatorSet.GetSystem("operating_system", out hv_OS);
            if ((int)((new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
                new HTuple(hv_Size_COPY_INP_TMP.TupleEqual(-1)))) != 0)
            {
                hv_Size_COPY_INP_TMP = 16;
            }
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                //Restore previous behaviour
                hv_Size_COPY_INP_TMP = ((1.13677 * hv_Size_COPY_INP_TMP)).TupleInt();
            }
            else
            {
                hv_Size_COPY_INP_TMP = hv_Size_COPY_INP_TMP.TupleInt();
            }
            if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("Courier"))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Courier";
                hv_Fonts[1] = "Courier 10 Pitch";
                hv_Fonts[2] = "Courier New";
                hv_Fonts[3] = "CourierNew";
                hv_Fonts[4] = "Liberation Mono";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("mono"))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Consolas";
                hv_Fonts[1] = "Menlo";
                hv_Fonts[2] = "Courier";
                hv_Fonts[3] = "Courier 10 Pitch";
                hv_Fonts[4] = "FreeMono";
                hv_Fonts[5] = "Liberation Mono";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("sans"))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Luxi Sans";
                hv_Fonts[1] = "DejaVu Sans";
                hv_Fonts[2] = "FreeSans";
                hv_Fonts[3] = "Arial";
                hv_Fonts[4] = "Liberation Sans";
            }
            else if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual("serif"))) != 0)
            {
                hv_Fonts = new HTuple();
                hv_Fonts[0] = "Times New Roman";
                hv_Fonts[1] = "Luxi Serif";
                hv_Fonts[2] = "DejaVu Serif";
                hv_Fonts[3] = "FreeSerif";
                hv_Fonts[4] = "Utopia";
                hv_Fonts[5] = "Liberation Serif";
            }
            else
            {
                hv_Fonts = hv_Font_COPY_INP_TMP.Clone();
            }
            hv_Style = "";
            if ((int)(new HTuple(hv_Bold.TupleEqual("true"))) != 0)
            {
                hv_Style = hv_Style + "Bold";
            }
            else if ((int)(new HTuple(hv_Bold.TupleNotEqual("false"))) != 0)
            {
                hv_Exception = "Wrong value of control parameter Bold";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Slant.TupleEqual("true"))) != 0)
            {
                hv_Style = hv_Style + "Italic";
            }
            else if ((int)(new HTuple(hv_Slant.TupleNotEqual("false"))) != 0)
            {
                hv_Exception = "Wrong value of control parameter Slant";
                throw new HalconException(hv_Exception);
            }
            if ((int)(new HTuple(hv_Style.TupleEqual(""))) != 0)
            {
                hv_Style = "Normal";
            }
            HOperatorSet.QueryFont(hv_WindowHandle, out hv_AvailableFonts);
            hv_Font_COPY_INP_TMP = "";
            for (hv_Fdx = 0; (int)hv_Fdx <= (int)((new HTuple(hv_Fonts.TupleLength())) - 1); hv_Fdx = (int)hv_Fdx + 1)
            {
                hv_Indices = hv_AvailableFonts.TupleFind(hv_Fonts.TupleSelect(hv_Fdx));
                if ((int)(new HTuple((new HTuple(hv_Indices.TupleLength())).TupleGreater(0))) != 0)
                {
                    if ((int)(new HTuple(((hv_Indices.TupleSelect(0))).TupleGreaterEqual(0))) != 0)
                    {
                        hv_Font_COPY_INP_TMP = hv_Fonts.TupleSelect(hv_Fdx);
                        break;
                    }
                }
            }
            if ((int)(new HTuple(hv_Font_COPY_INP_TMP.TupleEqual(""))) != 0)
            {
                throw new HalconException("Wrong value of control parameter Font");
            }
            hv_Font_COPY_INP_TMP = (((hv_Font_COPY_INP_TMP + "-") + hv_Style) + "-") + hv_Size_COPY_INP_TMP;
            HOperatorSet.SetFont(hv_WindowHandle, hv_Font_COPY_INP_TMP);

            return;
        }






        // Main procedure 
        private void action(HObject ho_Image, HObject ho_Rectangle, HObject ho_Rectangle1, out HTuple hv_dE)
        {

            // Local iconic variables 

            // Local iconic variables 

            HObject ho_ImageReduced;
            HObject ho_ImageReduced1, ho_ImageR, ho_ImageG;
            HObject ho_ImageB, ho_ImageR1, ho_ImageG1, ho_ImageB1, ho_ImageResultL;
            HObject ho_ImageResultA, ho_ImageResultB, ho_ImageResultL1;
            HObject ho_ImageResultA1, ho_ImageResultB1, ho_DomainL;
            HObject ho_DomainA, ho_DomainB, ho_DomainL1, ho_DomainA1;
            HObject ho_DomainB1;


            // Local control variables 

            HTuple hv_width, hv_height, hv_WindowsHandle = new HTuple();
            HTuple hv_Row1, hv_Column1, hv_Row2, hv_Column2, hv_Row11;
            HTuple hv_Column11, hv_Row12, hv_Column12, hv_L, hv_Deviation;
            HTuple hv_A, hv_B, hv_L1, hv_A1, hv_B1, hv_dL, hv_dA, hv_dB;
            HTuple hv_dL_2, hv_dA_2, hv_dB_2;

            // Initialize local and output iconic variables 
            //  HOperatorSet.GenEmptyObj(out ho_Image);
            //  HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            //    HOperatorSet.GenEmptyObj(out ho_Rectangle1);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced1);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            HOperatorSet.GenEmptyObj(out ho_ImageR1);
            HOperatorSet.GenEmptyObj(out ho_ImageG1);
            HOperatorSet.GenEmptyObj(out ho_ImageB1);
            HOperatorSet.GenEmptyObj(out ho_ImageResultL);
            HOperatorSet.GenEmptyObj(out ho_ImageResultA);
            HOperatorSet.GenEmptyObj(out ho_ImageResultB);
            HOperatorSet.GenEmptyObj(out ho_ImageResultL1);
            HOperatorSet.GenEmptyObj(out ho_ImageResultA1);
            HOperatorSet.GenEmptyObj(out ho_ImageResultB1);
            HOperatorSet.GenEmptyObj(out ho_DomainL);
            HOperatorSet.GenEmptyObj(out ho_DomainA);
            HOperatorSet.GenEmptyObj(out ho_DomainB);
            HOperatorSet.GenEmptyObj(out ho_DomainL1);
            HOperatorSet.GenEmptyObj(out ho_DomainA1);
            HOperatorSet.GenEmptyObj(out ho_DomainB1);


            // ho_Image.Dispose();
            // for (int i = 1; i <= 150; i++)
            //  {
            //   HOperatorSet.ReadImage(out ho_Image, "F:/1 ("+i+").bmp");

            //  HOperatorSet.GetImageSize(ho_Image, out hv_width, out hv_height);
            // dev_open_window_fit_image(ho_Image, 0, 0, -1, -1, out hv_WindowsHandle);
            //  HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);

            // HOperatorSet.DrawRectangle1(hv_WindowsHandle, out hv_Row1, out hv_Column1,
            //      out hv_Row2, out hv_Column2);
            //  ho_Rectangle.Dispose();
            // HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row1, hv_Column1, hv_Row2, hv_Column2);

            //   HOperatorSet.GenRectangle1(out ho_Rectangle,100,400+i * 10, 300,600 + i * 10);
            //  HOperatorSet.DispObj(ho_Rectangle, hv_ExpDefaultWinHandle);


            //  ho_ImageReduced.Dispose();
            //  HOperatorSet.ReduceDomain(ho_Image, ho_Rectangle, out ho_ImageReduced);

            // HOperatorSet.DrawRectangle1(hv_WindowsHandle, out hv_Row11, out hv_Column11,
            //      out hv_Row12, out hv_Column12);
            //  ho_Rectangle1.Dispose();
            // HOperatorSet.GenRectangle1(out ho_Rectangle1, hv_Row11, hv_Column11, hv_Row12,
            //     hv_Column12);
            // HOperatorSet.GenRectangle1(out ho_Rectangle1, 200, 400 + i * 10, 400, 600 + i * 10);
            //  HOperatorSet.DispObj(ho_Rectangle, hv_ExpDefaultWinHandle);
            //  ho_ImageReduced1.Dispose();
            //  HOperatorSet.ReduceDomain(ho_Image, ho_Rectangle1, out ho_ImageReduced1);

            ho_ImageR.Dispose();
            ho_ImageG.Dispose();
            ho_ImageB.Dispose();
            HOperatorSet.Decompose3(ho_Rectangle, out ho_ImageR, out ho_ImageG, out ho_ImageB
                );
            ho_ImageR1.Dispose();
            ho_ImageG1.Dispose();
            ho_ImageB1.Dispose();
            HOperatorSet.Decompose3(ho_Rectangle1, out ho_ImageR1, out ho_ImageG1, out ho_ImageB1
                );
            ho_ImageResultL.Dispose();
            ho_ImageResultA.Dispose();
            ho_ImageResultB.Dispose();
            HOperatorSet.TransFromRgb(ho_ImageR, ho_ImageG, ho_ImageB, out ho_ImageResultL,
                out ho_ImageResultA, out ho_ImageResultB, "cielab");
            ho_ImageResultL1.Dispose();
            ho_ImageResultA1.Dispose();
            ho_ImageResultB1.Dispose();
            HOperatorSet.TransFromRgb(ho_ImageR1, ho_ImageG1, ho_ImageB1, out ho_ImageResultL1,
                out ho_ImageResultA1, out ho_ImageResultB1, "cielab");
            ho_DomainL.Dispose();
            HOperatorSet.GetDomain(ho_ImageResultL, out ho_DomainL);
            ho_DomainA.Dispose();
            HOperatorSet.GetDomain(ho_ImageResultA, out ho_DomainA);
            ho_DomainB.Dispose();
            HOperatorSet.GetDomain(ho_ImageResultB, out ho_DomainB);
            ho_DomainL1.Dispose();
            HOperatorSet.GetDomain(ho_ImageResultL1, out ho_DomainL1);
            ho_DomainA1.Dispose();
            HOperatorSet.GetDomain(ho_ImageResultA1, out ho_DomainA1);
            ho_DomainB1.Dispose();
            HOperatorSet.GetDomain(ho_ImageResultB1, out ho_DomainB1);

            HOperatorSet.Intensity(ho_DomainL, ho_ImageResultL, out hv_L, out hv_Deviation);
            HOperatorSet.Intensity(ho_DomainA, ho_ImageResultA, out hv_A, out hv_Deviation);
            HOperatorSet.Intensity(ho_DomainB, ho_ImageResultB, out hv_B, out hv_Deviation);
            HOperatorSet.Intensity(ho_DomainL1, ho_ImageResultL1, out hv_L1, out hv_Deviation);
            HOperatorSet.Intensity(ho_DomainA1, ho_ImageResultA1, out hv_A1, out hv_Deviation);
            HOperatorSet.Intensity(ho_DomainB1, ho_ImageResultB1, out hv_B1, out hv_Deviation);

            HOperatorSet.TupleFabs(hv_L - hv_L1, out hv_dL);
            HOperatorSet.TupleFabs(hv_A - hv_A1, out hv_dA);
            HOperatorSet.TupleFabs(hv_B - hv_B1, out hv_dB);

            HOperatorSet.TuplePow(hv_dL, 2, out hv_dL_2);
            HOperatorSet.TuplePow(hv_dA, 2, out hv_dA_2);
            HOperatorSet.TuplePow(hv_dB, 2, out hv_dB_2);

            HOperatorSet.TupleSqrt((hv_dL_2 + hv_dA_2) + hv_dB_2, out hv_dE);
            // hv_ExpDefaultWinHandle = 200000;
            set_display_font(hv_ExpDefaultWinHandle, 20, "sans", "true", "false");
            //disp_message (WindowHandle, ['Hello','world!'], 'window', -1, -1, ['black','blue'], 'true')
            HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);


            //  HOperatorSet.DispObj(ho_Rectangle, hv_ExpDefaultWinHandle);

            //  HOperatorSet.DispObj(ho_Rectangle1, hv_ExpDefaultWinHandle);
            disp_message(hv_ExpDefaultWinHandle, "colordiff:" + hv_dE, "window", 50, 60, "black",
                    "true");

            //  ho_Image.Dispose();
            //   ho_Rectangle.Dispose();
            ho_ImageReduced.Dispose();
            //  ho_Rectangle1.Dispose();
            ho_ImageReduced1.Dispose();
            ho_ImageR.Dispose();
            ho_ImageG.Dispose();
            ho_ImageB.Dispose();
            ho_ImageR1.Dispose();
            ho_ImageG1.Dispose();
            ho_ImageB1.Dispose();
            ho_ImageResultL.Dispose();
            ho_ImageResultA.Dispose();
            ho_ImageResultB.Dispose();
            ho_ImageResultL1.Dispose();
            ho_ImageResultA1.Dispose();
            ho_ImageResultB1.Dispose();
            ho_DomainL.Dispose();
            ho_DomainA.Dispose();
            ho_DomainB.Dispose();
            ho_DomainL1.Dispose();
            ho_DomainA1.Dispose();
            ho_DomainB1.Dispose();
            //  }
            //  hv_dE = 50;
            // HOperatorSet.CloseWindow(3601);
        }

        // Procedures 
        // Local procedures 





        public void get_defect_aberration(HObject ho_Image, HTuple hv_WindowHandle, HTuple hv_boxNumber,
          HTuple hv_boxWidth, HTuple hv_boxHeight, HTuple hv_boxBenginX, HTuple hv_medianKernal,
          HTuple hv_thresh, HTuple hv_dynThresh, HTuple hv_defectWidth, HTuple hv_defectHeight,
          HTuple hv_defectArea, HTuple hv_standardTupleL, HTuple hv_standardTupleA, HTuple hv_standardTupleB,
          HTuple hv_clothAberrationGrad1, HTuple hv_clothAberrationGrad2, HTuple hv_clothAberrationGrad3,
          HTuple hv_clothAberrationGrad4, out HTuple hv_result, out HTuple hv_defectNumber,
          out HTuple hv_tupleDefectX, out HTuple hv_tupleDefectY, out HTuple hv_tupleDefectRadius,
          out HTuple hv_clothAberration, out HTuple hv_L, out HTuple hv_A, out HTuple hv_B)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];
            long SP_O = 0;

            // Local iconic variables 

            HObject ho_DefectRegion, ho_GrayImage, ho_Rectangle;
            HObject ho_Image1 = null, ho_Image2 = null, ho_Image3 = null;
            HObject ho_Regions1 = null, ho_RegionErosion1 = null, ho_ConnectedRegions1 = null;
            HObject ho_SelectedRegions1 = null, ho_ImageResult1 = null;
            HObject ho_ImageResult2 = null, ho_ImageResult3 = null, ho_SelectedRegions = null;
            HObject ho_SortedRegions = null, ho_ObjectSelected1 = null;
            HObject ho_ObjectSelected2 = null, ho_ClothRegion = null, ho_Boxs = null;
            HObject ho_ImageReduced = null, ho_ImageMedian = null, ho_Region1 = null;
            HObject ho_ImageMedianReduced = null, ho_ImageR = null, ho_ImageG = null;
            HObject ho_ImageB = null, ho_ImageL = null, ho_ImageA = null;
            HObject ho_ValidClothRegionGrayImage = null, ho_ImageMean1 = null;
            HObject ho_ImageMean2 = null, ho_RegionDynThresh = null, ho_ImageMean = null;
            HObject ho_ImageSub = null, ho_LightRegion = null, ho_LowGrayRegion = null;
            HObject ho_RegionUnion4 = null, ho_RegionErosion = null, ho_RegionIntersection = null;
            HObject ho_ConnectedRegions3 = null, ho_RegionDilation = null;


            // Local control variables 

            HTuple hv_DeviceIdentifier, hv_hasTransFormRGB;
            HTuple hv_DeviceHandle = new HTuple(), hv_Width, hv_Height;
            HTuple hv_Mean, hv_Deviation, hv_message = new HTuple();
            HTuple hv_Number = new HTuple(), hv_Row11 = new HTuple(), hv_Column11 = new HTuple();
            HTuple hv_Row21 = new HTuple(), hv_Column21 = new HTuple();
            HTuple hv_Row12 = new HTuple(), hv_Column12 = new HTuple();
            HTuple hv_Row22 = new HTuple(), hv_Column22 = new HTuple();
            HTuple hv_Convexity1 = new HTuple(), hv_Convexity2 = new HTuple();
            HTuple hv_Length = new HTuple(), hv_boxDistance = new HTuple();
            HTuple hv_boxBenginY = new HTuple(), hv_tupleDeviationL = new HTuple();
            HTuple hv_tupleDeviationA = new HTuple(), hv_tupleDeviationB = new HTuple();
            HTuple hv_i = new HTuple(), hv_MeanL = new HTuple(), hv_DeviationL = new HTuple();
            HTuple hv_MeanA = new HTuple(), hv_DeviationA = new HTuple();
            HTuple hv_MeanB = new HTuple(), hv_DeviationB = new HTuple();
            HTuple hv_tupleL = new HTuple(), hv_tupleA = new HTuple();
            HTuple hv_tupleB = new HTuple(), hv_aberrations = new HTuple();
            HTuple hv_j = new HTuple(), hv_a = new HTuple(), hv_aberrations1 = new HTuple();
            HTuple hv_tupleL1 = new HTuple(), hv_tupleA1 = new HTuple();
            HTuple hv_tupleB1 = new HTuple(), hv_total = new HTuple();
            HTuple hv_totalL = new HTuple(), hv_totalA = new HTuple();
            HTuple hv_totalB = new HTuple(), hv_k = new HTuple(), hv_Area = new HTuple();
            HTuple hv_Row = new HTuple(), hv_Column = new HTuple();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_DefectRegion);
            HOperatorSet.GenEmptyObj(out ho_GrayImage);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_Image1);
            HOperatorSet.GenEmptyObj(out ho_Image2);
            HOperatorSet.GenEmptyObj(out ho_Image3);
            HOperatorSet.GenEmptyObj(out ho_Regions1);
            HOperatorSet.GenEmptyObj(out ho_RegionErosion1);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_ImageResult1);
            HOperatorSet.GenEmptyObj(out ho_ImageResult2);
            HOperatorSet.GenEmptyObj(out ho_ImageResult3);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
            HOperatorSet.GenEmptyObj(out ho_SortedRegions);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected1);
            HOperatorSet.GenEmptyObj(out ho_ObjectSelected2);
            HOperatorSet.GenEmptyObj(out ho_ClothRegion);
            HOperatorSet.GenEmptyObj(out ho_Boxs);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageMedian);
            HOperatorSet.GenEmptyObj(out ho_Region1);
            HOperatorSet.GenEmptyObj(out ho_ImageMedianReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            HOperatorSet.GenEmptyObj(out ho_ImageL);
            HOperatorSet.GenEmptyObj(out ho_ImageA);
            HOperatorSet.GenEmptyObj(out ho_ValidClothRegionGrayImage);
            HOperatorSet.GenEmptyObj(out ho_ImageMean1);
            HOperatorSet.GenEmptyObj(out ho_ImageMean2);
            HOperatorSet.GenEmptyObj(out ho_RegionDynThresh);
            HOperatorSet.GenEmptyObj(out ho_ImageMean);
            HOperatorSet.GenEmptyObj(out ho_ImageSub);
            HOperatorSet.GenEmptyObj(out ho_LightRegion);
            HOperatorSet.GenEmptyObj(out ho_LowGrayRegion);
            HOperatorSet.GenEmptyObj(out ho_RegionUnion4);
            HOperatorSet.GenEmptyObj(out ho_RegionErosion);
            HOperatorSet.GenEmptyObj(out ho_RegionIntersection);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions3);
            HOperatorSet.GenEmptyObj(out ho_RegionDilation);


            hv_thresh = PublicClass.Thresh;
            ////sideWidth边上不检测的像素值
           // hv_sideWidth = PublicClass.sideWidth;
            //检测阈值10
            hv_dynThresh = PublicClass.dynthresh;
            //缺陷长度
            hv_defectWidth = PublicClass.ra;
            hv_defectHeight = PublicClass.ra;
            hv_defectArea = PublicClass.defectArea;

           hv_defectNumber = new HTuple();
            hv_tupleDefectX = new HTuple();
            hv_tupleDefectY = new HTuple();
            hv_tupleDefectRadius = new HTuple();
            hv_ExpDefaultWinHandle = hv_WindowHandle;
            HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
            //   set_display_font(hv_ExpDefaultWinHandle, 20, "sans", "true", "false");
            hv_result = 0;
            hv_L = 0;
            hv_A = 0;
            hv_B = 0;
            hv_clothAberration = 0;
            ho_DefectRegion.Dispose();
            HOperatorSet.GenEmptyObj(out ho_DefectRegion);
            HOperatorSet.QueryAvailableComputeDevices(out hv_DeviceIdentifier);
            hv_hasTransFormRGB = 0;
            if ((int)(new HTuple((new HTuple(hv_DeviceIdentifier.TupleLength())).TupleGreater(
                0))) != 0)
            {
                HOperatorSet.OpenComputeDevice(hv_DeviceIdentifier.TupleSelect(0), out hv_DeviceHandle);
                //Deactivate asynchronous execution to obtain reliable benchmarks.
                HOperatorSet.SetComputeDeviceParam(hv_DeviceHandle, "asynchronous_execution",
                    "false");

            }
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            ho_GrayImage.Dispose();
            HOperatorSet.Rgb1ToGray(ho_Image, out ho_GrayImage);
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Height - 1000, 1000, hv_Height,
                hv_Width - 1000);
            HOperatorSet.Intensity(ho_Rectangle, ho_GrayImage, out hv_Mean, out hv_Deviation);
            if ((int)(new HTuple(hv_Mean.TupleGreater(230))) != 0)
            {
                hv_result = 10;
                hv_message = "检测结果：图片过亮";
                disp_message(hv_ExpDefaultWinHandle, hv_message, "window", 10, 100, "green",
                    "true");
            }
            else
            {
                if ((int)(new HTuple(hv_Mean.TupleLess(20))) != 0)
                {
                    hv_result = 11;
                    hv_message = "检测结果：图片过暗";
                    disp_message(hv_ExpDefaultWinHandle, hv_message, "window", 10, 100, "green",
                        "true");
                }
            }

            if ((int)(new HTuple(hv_result.TupleEqual(0))) != 0)
            {
                ho_Image1.Dispose();
                ho_Image2.Dispose();
                ho_Image3.Dispose();
                HOperatorSet.Decompose3(ho_Image, out ho_Image1, out ho_Image2, out ho_Image3
                    );
                ho_Regions1.Dispose();
                HOperatorSet.AutoThreshold(ho_Image1, out ho_Regions1, 4);
                ho_RegionErosion1.Dispose();
                HOperatorSet.OpeningCircle(ho_Regions1, out ho_RegionErosion1, 10);
                ho_ConnectedRegions1.Dispose();
                HOperatorSet.Connection(ho_RegionErosion1, out ho_ConnectedRegions1);
                ho_SelectedRegions1.Dispose();
                HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                    "and", hv_Width / 2, hv_Width - 800);
                HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_Image2, out ho_Regions1, 4);
                    ho_RegionErosion1.Dispose();
                    HOperatorSet.OpeningCircle(ho_Regions1, out ho_RegionErosion1, 10);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_RegionErosion1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_Image3, out ho_Regions1, 4);
                    ho_RegionErosion1.Dispose();
                    HOperatorSet.OpeningCircle(ho_Regions1, out ho_RegionErosion1, 10);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_RegionErosion1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        HOperatorSet.InitComputeDevice(hv_DeviceHandle, "  trans_from_rgb ");
                        HOperatorSet.ActivateComputeDevice(hv_DeviceHandle);
                    }
                    ho_ImageResult1.Dispose();
                    ho_ImageResult2.Dispose();
                    ho_ImageResult3.Dispose();
                    HOperatorSet.TransFromRgb(ho_Image1, ho_Image2, ho_Image3, out ho_ImageResult1,
                        out ho_ImageResult2, out ho_ImageResult3, "cielab");
                    if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        HOperatorSet.DeactivateComputeDevice(hv_DeviceHandle);
                    }
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_ImageResult2, out ho_Regions1, 1);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_Regions1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_ImageResult1, out ho_Regions1, 1);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_Regions1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }

                ho_SelectedRegions.Dispose();
                HOperatorSet.FillUp(ho_SelectedRegions1, out ho_SelectedRegions);
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    //未找到布匹
                    hv_result = 1;
                    disp_message(hv_ExpDefaultWinHandle, "未找到布匹", "window", 10, 100,
                        "red", "true");
                }
                else if ((int)(new HTuple(hv_Number.TupleGreater(1))) != 0)
                {
                    ho_SortedRegions.Dispose();
                    HOperatorSet.SortRegion(ho_SelectedRegions, out ho_SortedRegions, "first_point",
                        "true", "row");
                    ho_ObjectSelected1.Dispose();
                    HOperatorSet.SelectObj(ho_SortedRegions, out ho_ObjectSelected1, 1);
                    ho_ObjectSelected2.Dispose();
                    HOperatorSet.SelectObj(ho_SortedRegions, out ho_ObjectSelected2, 2);
                    HOperatorSet.SmallestRectangle1(ho_ObjectSelected1, out hv_Row11, out hv_Column11,
                        out hv_Row21, out hv_Column21);
                    HOperatorSet.SmallestRectangle1(ho_ObjectSelected2, out hv_Row12, out hv_Column12,
                        out hv_Row22, out hv_Column22);
                    HOperatorSet.Convexity(ho_ObjectSelected1, out hv_Convexity1);
                    HOperatorSet.Convexity(ho_ObjectSelected2, out hv_Convexity2);
                    if ((int)((new HTuple((new HTuple(hv_Column11.TupleLess(2))).TupleAnd(new HTuple(hv_Column22.TupleGreater(
                        hv_Height - 2))))).TupleAnd((new HTuple(hv_Convexity1.TupleLess(0.97))).TupleOr(
                        new HTuple(hv_Convexity2.TupleLess(0.97))))) != 0)
                    {
                        //接缝布匹
                        hv_result = 2;
                    }
                    else
                    {
                        //布匹有长瑕疵
                        hv_result = 3;
                        ho_DefectRegion.Dispose();
                        HOperatorSet.SelectShape(ho_SelectedRegions, out ho_DefectRegion, "height",
                            "and", 1, hv_Height / 3);
                    }
                }
                //gen_rectangle1 (Rectangle1, 1, 0, 2, Width)
                //gen_rectangle1 (Rectangle2, Height-1, 1, Height, Width)
                //union2 (Rectangle1, Rectangle2, RegionUnion1)
                //union2 (RegionUnion1, SelectedRegions, RegionUnion2)
                ho_ClothRegion.Dispose();
                HOperatorSet.FillUp(ho_SelectedRegions, out ho_ClothRegion);
                OTemp[SP_O] = ho_ClothRegion.CopyObj(1, -1);
                SP_O++;
                ho_ClothRegion.Dispose();
                HOperatorSet.OpeningRectangle1(OTemp[SP_O - 1], out ho_ClothRegion, 1, 3);
                OTemp[SP_O - 1].Dispose();
                SP_O = 0;
                //union2 (RegionUnion1, SelectedRegions, RegionUnion2)
                HOperatorSet.TupleLength(hv_standardTupleL, out hv_Length);
                if ((int)((new HTuple(hv_result.TupleEqual(0))).TupleAnd(new HTuple(hv_Length.TupleGreaterEqual(
                    hv_boxNumber)))) != 0)
                {
                    //色差检测
                    //boxDistance表示两个框间距
                    hv_boxDistance = ((hv_Width - (hv_boxNumber * hv_boxWidth)) - (hv_boxBenginX * 2)) / (hv_boxNumber - 1);
                    //，boxBenginY框起始y坐标
                    hv_boxBenginY = (hv_Height - hv_boxHeight) / 2;
                    hv_tupleDeviationL = new HTuple();
                    hv_tupleDeviationA = new HTuple();
                    hv_tupleDeviationB = new HTuple();
                    ho_Boxs.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_Boxs);
                    for (hv_i = 0; hv_i.Continue(hv_boxNumber - 1, 1); hv_i = hv_i.TupleAdd(1))
                    {
                        ho_Rectangle.Dispose();
                        HOperatorSet.GenRectangle1(out ho_Rectangle, hv_boxBenginY, hv_boxBenginX + (hv_i * (hv_boxWidth + hv_boxDistance)),
                            hv_boxBenginY + hv_boxHeight, (hv_boxBenginX + (hv_i * (hv_boxWidth + hv_boxDistance))) + hv_boxWidth);
                        OTemp[SP_O] = ho_Boxs.CopyObj(1, -1);
                        SP_O++;
                        ho_Boxs.Dispose();
                        HOperatorSet.Union2(OTemp[SP_O - 1], ho_Rectangle, out ho_Boxs);
                        OTemp[SP_O - 1].Dispose();
                        SP_O = 0;
                        ho_ImageReduced.Dispose();
                        HOperatorSet.ReduceDomain(ho_Image, ho_Rectangle, out ho_ImageReduced);
                        if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            HOperatorSet.InitComputeDevice(hv_DeviceHandle, " median_image ");
                            HOperatorSet.ActivateComputeDevice(hv_DeviceHandle);
                        }
                        ho_ImageMedian.Dispose();
                        HOperatorSet.MedianImage(ho_ImageReduced, out ho_ImageMedian, "circle",
                            hv_medianKernal * 0.5, "cyclic");
                        if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            HOperatorSet.DeactivateComputeDevice(hv_DeviceHandle);
                        }
                        ho_Region1.Dispose();
                        HOperatorSet.VarThreshold(ho_ImageMedian, out ho_Region1, 25, 25, 0.2,
                            2, "equal");
                        ho_ImageMedianReduced.Dispose();
                        HOperatorSet.ReduceDomain(ho_ImageMedian, ho_Region1, out ho_ImageMedianReduced
                            );
                        if ((int)(new HTuple(hv_hasTransFormRGB.TupleEqual(0))) != 0)
                        {
                            ho_ImageR.Dispose();
                            ho_ImageG.Dispose();
                            ho_ImageB.Dispose();
                            HOperatorSet.Decompose3(ho_ImageMedianReduced, out ho_ImageR, out ho_ImageG,
                                out ho_ImageB);
                            if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                HOperatorSet.InitComputeDevice(hv_DeviceHandle, "trans_from_rgb");
                                HOperatorSet.ActivateComputeDevice(hv_DeviceHandle);
                            }
                            OTemp[SP_O] = ho_ImageB.CopyObj(1, -1);
                            SP_O++;
                            ho_ImageL.Dispose();
                            ho_ImageA.Dispose();
                            ho_ImageB.Dispose();
                            HOperatorSet.TransFromRgb(ho_ImageR, ho_ImageG, OTemp[SP_O - 1], out ho_ImageL,
                                out ho_ImageA, out ho_ImageB, "cielab");
                            OTemp[SP_O - 1].Dispose();
                            SP_O = 0;
                            if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                HOperatorSet.DeactivateComputeDevice(hv_DeviceHandle);
                            }
                        }
                        else
                        {
                            ho_ImageL.Dispose();
                            HOperatorSet.ReduceDomain(ho_ImageResult1, ho_Rectangle, out ho_ImageL
                                );
                            ho_ImageA.Dispose();
                            HOperatorSet.ReduceDomain(ho_ImageResult2, ho_Rectangle, out ho_ImageA
                                );
                            ho_ImageB.Dispose();
                            HOperatorSet.ReduceDomain(ho_ImageResult3, ho_Rectangle, out ho_ImageB
                                );
                        }
                        HOperatorSet.Intensity(ho_Rectangle, ho_ImageL, out hv_MeanL, out hv_DeviationL);
                        HOperatorSet.Intensity(ho_Rectangle, ho_ImageA, out hv_MeanA, out hv_DeviationA);
                        HOperatorSet.Intensity(ho_Rectangle, ho_ImageB, out hv_MeanB, out hv_DeviationB);
                        hv_tupleL[hv_i] = hv_MeanL;
                        hv_tupleA[hv_i] = hv_MeanA;
                        hv_tupleB[hv_i] = hv_MeanB;
                        hv_tupleDeviationL[hv_i] = hv_DeviationL;
                        hv_tupleDeviationA[hv_i] = hv_DeviationA;
                        hv_tupleDeviationB[hv_i] = hv_DeviationB;
                    }
                    HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "green");
                    HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "margin");
                    HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 2);
                    HOperatorSet.DispObj(ho_Boxs, hv_ExpDefaultWinHandle);
                    hv_aberrations = new HTuple();
                    for (hv_j = 0; hv_j.Continue(hv_boxNumber - 1, 1); hv_j = hv_j.TupleAdd(1))
                    {
                        HOperatorSet.TupleSqrt(((((hv_tupleL.TupleSelect(hv_j)) - (hv_standardTupleL.TupleSelect(
                            hv_j))) * ((hv_tupleL.TupleSelect(hv_j)) - (hv_standardTupleL.TupleSelect(
                            hv_j)))) + (((hv_tupleA.TupleSelect(hv_j)) - (hv_standardTupleA.TupleSelect(
                            hv_j))) * ((hv_tupleA.TupleSelect(hv_j)) - (hv_standardTupleA.TupleSelect(
                            hv_j))))) + (((hv_tupleB.TupleSelect(hv_j)) - (hv_standardTupleB.TupleSelect(
                            hv_j))) * ((hv_tupleB.TupleSelect(hv_j)) - (hv_standardTupleB.TupleSelect(
                            hv_j)))), out hv_a);
                        //c := (tupleL[j]-standardTupleL[j])*(tupleL[j]-standardTupleL[j])
                        //d := (tupleA[j]-standardTupleA[j])*(tupleA[j]-standardTupleA[j])
                        //e := (tupleB[j]-standardTupleB[j])*(tupleB[j]-standardTupleB[j])
                        hv_aberrations[hv_j] = hv_a;
                    }
                    HOperatorSet.TupleSort(hv_aberrations, out hv_aberrations1);
                    HOperatorSet.TupleSort(hv_tupleL, out hv_tupleL1);
                    HOperatorSet.TupleSort(hv_tupleA, out hv_tupleA1);
                    HOperatorSet.TupleSort(hv_tupleB, out hv_tupleB1);
                    if ((int)(new HTuple(hv_boxNumber.TupleGreater(2))) != 0)
                    {
                        hv_total = 0;
                        hv_totalL = 0;
                        hv_totalA = 0;
                        hv_totalB = 0;
                        for (hv_k = 1; hv_k.Continue(hv_boxNumber - 2, 1); hv_k = hv_k.TupleAdd(1))
                        {
                            hv_total = hv_total + (hv_aberrations1.TupleSelect(hv_k));
                            hv_totalL = hv_totalL + (hv_tupleL1.TupleSelect(hv_k));
                            hv_totalA = hv_totalA + (hv_tupleA1.TupleSelect(hv_k));
                            hv_totalB = hv_totalB + (hv_tupleB1.TupleSelect(hv_k));
                        }
                        hv_clothAberration = hv_total / (hv_boxNumber - 2);
                        hv_L = hv_totalL / (hv_boxNumber - 2);
                        hv_A = hv_totalA / (hv_boxNumber - 2);
                        hv_B = hv_totalB / (hv_boxNumber - 2);
                    }
                    else
                    {
                        hv_clothAberration = hv_aberrations[0];
                        hv_L = hv_tupleL1[0];
                        hv_A = hv_tupleA1[0];
                        hv_B = hv_tupleB1[0];
                    }

                    //tuple_max (aberrations, clothAberration)
                    if ((int)(new HTuple(hv_clothAberration.TupleLess(hv_clothAberrationGrad1))) != 0)
                    {
                        disp_message(hv_ExpDefaultWinHandle, ("色差值：" + hv_clothAberration) + "（色差等级：一级色差）",
                            "window", 10, 100, "green", "true");
                    }
                    else
                    {
                        if ((int)(new HTuple(hv_clothAberration.TupleLess(hv_clothAberrationGrad2))) != 0)
                        {
                            disp_message(hv_ExpDefaultWinHandle, ("色差值：" + hv_clothAberration) + "（色差等级：二级色差）",
                                "window", 10, 100, "lime green", "true");
                        }
                        else
                        {
                            if ((int)(new HTuple(hv_clothAberration.TupleLess(hv_clothAberrationGrad3))) != 0)
                            {
                                disp_message(hv_ExpDefaultWinHandle, ("色差值：" + hv_clothAberration) + "（色差等级：三级色差）",
                                    "window", 10, 100, "orange", "true");
                            }
                            else
                            {
                                if ((int)(new HTuple(hv_clothAberration.TupleLess(hv_clothAberrationGrad4))) != 0)
                                {
                                    disp_message(hv_ExpDefaultWinHandle, ("色差值：" + hv_clothAberration) + "（色差等级：四级色差）",
                                        "window", 10, 100, "magenta", "true");
                                }
                                else
                                {
                                    disp_message(hv_ExpDefaultWinHandle, ("色差值：" + hv_clothAberration) + "（色差等级：五级色差）",
                                        "window", 10, 100, "red", "true");

                                }
                            }
                        }
                    }
                }

                if ((int)((new HTuple(hv_Length.TupleLess(hv_boxNumber))).TupleAnd(new HTuple(hv_result.TupleEqual(
                    0)))) != 0)
                {
                    disp_message(hv_ExpDefaultWinHandle, "缺少标准色差参数", "window",
                        10, 100, "red", "false");
                }
                if ((int)(new HTuple(hv_result.TupleEqual(0))) != 0)
                {
                    //瑕疵检测
                    ho_ValidClothRegionGrayImage.Dispose();
                    HOperatorSet.ReduceDomain(ho_GrayImage, ho_ClothRegion, out ho_ValidClothRegionGrayImage
                        );
                    OTemp[SP_O] = ho_ValidClothRegionGrayImage.CopyObj(1, -1);
                    SP_O++;
                    ho_ValidClothRegionGrayImage.Dispose();
                    HOperatorSet.MedianImage(OTemp[SP_O - 1], out ho_ValidClothRegionGrayImage,
                        "circle", 2, "mirrored");
                    OTemp[SP_O - 1].Dispose();
                    SP_O = 0;
                    ho_ImageMean1.Dispose();
                    HOperatorSet.MeanImage(ho_ValidClothRegionGrayImage, out ho_ImageMean1, 10,
                        10);
                    ho_ImageMean2.Dispose();
                    HOperatorSet.MeanImage(ho_ValidClothRegionGrayImage, out ho_ImageMean2, 50,
                        50);
                    ho_RegionDynThresh.Dispose();
                    HOperatorSet.DynThreshold(ho_ImageMean1, ho_ImageMean2, out ho_RegionDynThresh,
                        hv_dynThresh, "not_equal");

                    ho_ImageMean.Dispose();
                    HOperatorSet.RegionToMean(ho_ClothRegion, ho_GrayImage, out ho_ImageMean);
                    //mean_image (ValidClothRegionGrayImage, ImageMean, 100, 100)
                    ho_ImageSub.Dispose();
                    HOperatorSet.SubImage(ho_ValidClothRegionGrayImage, ho_ImageMean, out ho_ImageSub,
                        1, 128);
                    ho_LightRegion.Dispose();
                    HOperatorSet.Threshold(ho_ImageSub, out ho_LightRegion, 128 + hv_thresh, 255);
                    ho_LowGrayRegion.Dispose();
                    HOperatorSet.Threshold(ho_ImageSub, out ho_LowGrayRegion, 0, 128 - hv_thresh);


                    //intensity (ClothRegion, GrayImage, ValidClothRegionGrayImageMean, Deviation)
                    //tuple_max2 (20, ValidClothRegionGrayImageMean-50, Max2)
                    //tuple_min2 (235, ValidClothRegionGrayImageMean+50, Min2)

                    //threshold (ValidClothRegionGrayImage, LowGrayRegion, 0, Max2)
                    //threshold (ValidClothRegionGrayImage, LightRegion, Min2, 255)
                    ho_RegionUnion4.Dispose();
                    HOperatorSet.Union2(ho_LightRegion, ho_LowGrayRegion, out ho_RegionUnion4
                        );
                    OTemp[SP_O] = ho_RegionUnion4.CopyObj(1, -1);
                    SP_O++;
                    ho_RegionUnion4.Dispose();
                    HOperatorSet.Union2(ho_RegionDynThresh, OTemp[SP_O - 1], out ho_RegionUnion4
                        );
                    OTemp[SP_O - 1].Dispose();
                    SP_O = 0;
                    ho_RegionErosion.Dispose();
                    HOperatorSet.ErosionRectangle1(ho_ClothRegion, out ho_RegionErosion, 50,
                        5);
                    ho_RegionIntersection.Dispose();
                    HOperatorSet.Intersection(ho_RegionErosion, ho_RegionUnion4, out ho_RegionIntersection
                        );
                    ho_ConnectedRegions3.Dispose();
                    HOperatorSet.Connection(ho_RegionIntersection, out ho_ConnectedRegions3);
                    ho_DefectRegion.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions3, out ho_DefectRegion, ((new HTuple("area")).TupleConcat(
                        "rb")).TupleConcat("ra"), "or", ((hv_defectArea.TupleConcat(hv_defectWidth / 2))).TupleConcat(
                        hv_defectHeight / 2), ((new HTuple(500000)).TupleConcat(200000)).TupleConcat(
                        200000));

                }
                HOperatorSet.AreaCenter(ho_DefectRegion, out hv_Area, out hv_Row, out hv_Column);
                if ((int)(new HTuple(hv_Area.TupleGreater(0))) != 0)
                {
                    ho_RegionDilation.Dispose();
                    HOperatorSet.DilationCircle(ho_DefectRegion, out ho_RegionDilation, 40);
                    OTemp[SP_O] = ho_RegionDilation.CopyObj(1, -1);
                    SP_O++;
                    ho_RegionDilation.Dispose();
                    HOperatorSet.Union1(OTemp[SP_O - 1], out ho_RegionDilation);
                    OTemp[SP_O - 1].Dispose();
                    SP_O = 0;
                    HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);
                    HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 3);
                    HOperatorSet.DispObj(ho_RegionDilation, hv_ExpDefaultWinHandle);
                    HOperatorSet.OverpaintRegion(ho_Image, ho_RegionDilation, ((new HTuple(255)).TupleConcat(
                        0)).TupleConcat(0), "margin");

                    hv_result = 3;

                }
            }

            ho_DefectRegion.Dispose();
            ho_GrayImage.Dispose();
            ho_Rectangle.Dispose();
            ho_Image1.Dispose();
            ho_Image2.Dispose();
            ho_Image3.Dispose();
            ho_Regions1.Dispose();
            ho_RegionErosion1.Dispose();
            ho_ConnectedRegions1.Dispose();
            ho_SelectedRegions1.Dispose();
            ho_ImageResult1.Dispose();
            ho_ImageResult2.Dispose();
            ho_ImageResult3.Dispose();
            ho_SelectedRegions.Dispose();
            ho_SortedRegions.Dispose();
            ho_ObjectSelected1.Dispose();
            ho_ObjectSelected2.Dispose();
            ho_ClothRegion.Dispose();
            ho_Boxs.Dispose();
            ho_ImageReduced.Dispose();
            ho_ImageMedian.Dispose();
            ho_Region1.Dispose();
            ho_ImageMedianReduced.Dispose();
            ho_ImageR.Dispose();
            ho_ImageG.Dispose();
            ho_ImageB.Dispose();
            ho_ImageL.Dispose();
            ho_ImageA.Dispose();
            ho_ValidClothRegionGrayImage.Dispose();
            ho_ImageMean1.Dispose();
            ho_ImageMean2.Dispose();
            ho_RegionDynThresh.Dispose();
            ho_ImageMean.Dispose();
            ho_ImageSub.Dispose();
            ho_LightRegion.Dispose();
            ho_LowGrayRegion.Dispose();
            ho_RegionUnion4.Dispose();
            ho_RegionErosion.Dispose();
            ho_RegionIntersection.Dispose();
            ho_ConnectedRegions3.Dispose();
            ho_RegionDilation.Dispose();

            return;
        }

        public void get_standard_lab(HObject ho_Image, HTuple hv_WindowHandle, HTuple hv_boxNumber, HTuple hv_boxWidth,
            HTuple hv_boxHeight, HTuple hv_boxBenginX, HTuple hv_medianKernal, out HTuple hv_standardTupleL,
            out HTuple hv_standardTupleA, out HTuple hv_standardTupleB, out HTuple hv_standardL,
            out HTuple hv_standardA, out HTuple hv_standardB, out HTuple hv_result)
        {



            // Stack for temporary objects 
            HObject[] OTemp = new HObject[20];
            long SP_O = 0;

            // Local iconic variables 

            HObject ho_GrayImage, ho_Rectangle, ho_Image1 = null;
            HObject ho_Image2 = null, ho_Image3 = null, ho_Regions1 = null;
            HObject ho_RegionErosion1 = null, ho_ConnectedRegions1 = null;
            HObject ho_SelectedRegions1 = null, ho_ImageResult1 = null;
            HObject ho_ImageResult2 = null, ho_ImageResult3 = null, ho_SelectedRegions = null;
            HObject ho_Boxs = null, ho_ImageReduced = null, ho_ImageMedian = null;
            HObject ho_Region1 = null, ho_ImageMedianReduced = null, ho_ImageR = null;
            HObject ho_ImageG = null, ho_ImageB = null, ho_ImageL = null;
            HObject ho_ImageA = null;


            // Local control variables 

            HTuple hv_Width;
            HTuple hv_Height, hv_Mean, hv_Deviation, hv_message = new HTuple();
            HTuple hv_Number = new HTuple(), hv_DeviceIdentifier = new HTuple();
            HTuple hv_hasTransFormRGB = new HTuple(), hv_DeviceHandle = new HTuple();
            HTuple hv_boxDistance = new HTuple(), hv_boxBenginY = new HTuple();
            HTuple hv_tupleDeviationL = new HTuple(), hv_tupleDeviationA = new HTuple();
            HTuple hv_tupleDeviationB = new HTuple(), hv_i = new HTuple();
            HTuple hv_MeanL = new HTuple(), hv_DeviationL = new HTuple();
            HTuple hv_MeanA = new HTuple(), hv_DeviationA = new HTuple();
            HTuple hv_MeanB = new HTuple(), hv_DeviationB = new HTuple();
            HTuple hv_standardTupleL1 = new HTuple(), hv_standardTupleA1 = new HTuple();
            HTuple hv_standardTupleB1 = new HTuple(), hv_totalL = new HTuple();
            HTuple hv_totalA = new HTuple(), hv_totalB = new HTuple();
            HTuple hv_k = new HTuple();

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_GrayImage);
            HOperatorSet.GenEmptyObj(out ho_Rectangle);
            HOperatorSet.GenEmptyObj(out ho_Image1);
            HOperatorSet.GenEmptyObj(out ho_Image2);
            HOperatorSet.GenEmptyObj(out ho_Image3);
            HOperatorSet.GenEmptyObj(out ho_Regions1);
            HOperatorSet.GenEmptyObj(out ho_RegionErosion1);
            HOperatorSet.GenEmptyObj(out ho_ConnectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
            HOperatorSet.GenEmptyObj(out ho_ImageResult1);
            HOperatorSet.GenEmptyObj(out ho_ImageResult2);
            HOperatorSet.GenEmptyObj(out ho_ImageResult3);
            HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
            HOperatorSet.GenEmptyObj(out ho_Boxs);
            HOperatorSet.GenEmptyObj(out ho_ImageReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageMedian);
            HOperatorSet.GenEmptyObj(out ho_Region1);
            HOperatorSet.GenEmptyObj(out ho_ImageMedianReduced);
            HOperatorSet.GenEmptyObj(out ho_ImageR);
            HOperatorSet.GenEmptyObj(out ho_ImageG);
            HOperatorSet.GenEmptyObj(out ho_ImageB);
            HOperatorSet.GenEmptyObj(out ho_ImageL);
            HOperatorSet.GenEmptyObj(out ho_ImageA);


           

            hv_standardTupleL = new HTuple();
            hv_standardTupleA = new HTuple();
            hv_standardTupleB = new HTuple();
            hv_standardL = new HTuple();
            hv_standardA = new HTuple();
            hv_standardB = new HTuple();
            hv_result = 0;
            //dev_open_window(...);
            hv_ExpDefaultWinHandle = hv_WindowHandle;
            //  set_display_font(hv_ExpDefaultWinHandle, 20, "sans", "true", "false");
            ho_GrayImage.Dispose();
            HOperatorSet.Rgb1ToGray(ho_Image, out ho_GrayImage);
            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            ho_Rectangle.Dispose();
            HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Height - 1000, 1000, hv_Height,
                hv_Width - 1000);
            HOperatorSet.Intensity(ho_Rectangle, ho_GrayImage, out hv_Mean, out hv_Deviation);
            if ((int)(new HTuple(hv_Mean.TupleGreater(230))) != 0)
            {
                hv_result = 10;
                hv_message = "标准色差获取失败，图片过亮";
                disp_message(hv_ExpDefaultWinHandle, hv_message, "window", 10, 100, "green",
                    "true");
            }
            else
            {
                if ((int)(new HTuple(hv_Mean.TupleLess(20))) != 0)
                {
                    hv_result = 11;
                    hv_message = "标准色差获取失败，图片过暗";
                    disp_message(hv_ExpDefaultWinHandle, hv_message, "window", 10, 100, "green",
                        "true");
                }
            }
            if ((int)(new HTuple(hv_result.TupleEqual(0))) != 0)
            {
                ho_Image1.Dispose();
                ho_Image2.Dispose();
                ho_Image3.Dispose();
                HOperatorSet.Decompose3(ho_Image, out ho_Image1, out ho_Image2, out ho_Image3
                    );
                ho_Regions1.Dispose();
                HOperatorSet.AutoThreshold(ho_Image1, out ho_Regions1, 4);
                ho_RegionErosion1.Dispose();
                HOperatorSet.OpeningCircle(ho_Regions1, out ho_RegionErosion1, 10);
                ho_ConnectedRegions1.Dispose();
                HOperatorSet.Connection(ho_RegionErosion1, out ho_ConnectedRegions1);
                ho_SelectedRegions1.Dispose();
                HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                    "and", hv_Width / 2, hv_Width - 400);
                HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                HOperatorSet.QueryAvailableComputeDevices(out hv_DeviceIdentifier);
                hv_hasTransFormRGB = 0;
                if ((int)(new HTuple((new HTuple(hv_DeviceIdentifier.TupleLength())).TupleGreater(
                    0))) != 0)
                {
                    HOperatorSet.OpenComputeDevice(hv_DeviceIdentifier.TupleSelect(0), out hv_DeviceHandle);
                    //Deactivate asynchronous execution to obtain reliable benchmarks.
                    HOperatorSet.SetComputeDeviceParam(hv_DeviceHandle, "asynchronous_execution",
                        "false");

                }
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_Image2, out ho_Regions1, 4);
                    ho_RegionErosion1.Dispose();
                    HOperatorSet.OpeningCircle(ho_Regions1, out ho_RegionErosion1, 10);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_RegionErosion1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_Image3, out ho_Regions1, 4);
                    ho_RegionErosion1.Dispose();
                    HOperatorSet.OpeningCircle(ho_Regions1, out ho_RegionErosion1, 10);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_RegionErosion1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        HOperatorSet.InitComputeDevice(hv_DeviceHandle, "  trans_from_rgb ");
                        HOperatorSet.ActivateComputeDevice(hv_DeviceHandle);
                    }
                    ho_ImageResult1.Dispose();
                    ho_ImageResult2.Dispose();
                    ho_ImageResult3.Dispose();
                    HOperatorSet.TransFromRgb(ho_Image1, ho_Image2, ho_Image3, out ho_ImageResult1,
                        out ho_ImageResult2, out ho_ImageResult3, "cielab");
                    hv_hasTransFormRGB = 1;
                    if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                        0))) != 0)
                    {
                        HOperatorSet.DeactivateComputeDevice(hv_DeviceHandle);
                    }
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_ImageResult2, out ho_Regions1, 1);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_Regions1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    ho_Regions1.Dispose();
                    HOperatorSet.AutoThreshold(ho_ImageResult1, out ho_Regions1, 1);
                    ho_ConnectedRegions1.Dispose();
                    HOperatorSet.Connection(ho_Regions1, out ho_ConnectedRegions1);
                    ho_SelectedRegions1.Dispose();
                    HOperatorSet.SelectShape(ho_ConnectedRegions1, out ho_SelectedRegions1, "width",
                        "and", hv_Width / 2, hv_Width - 800);
                    HOperatorSet.CountObj(ho_SelectedRegions1, out hv_Number);
                }

                ho_SelectedRegions.Dispose();
                HOperatorSet.FillUp(ho_SelectedRegions1, out ho_SelectedRegions);
                if ((int)(new HTuple(hv_Number.TupleEqual(0))) != 0)
                {
                    hv_result = 1;
                    //未找到布匹
                    disp_message(hv_ExpDefaultWinHandle, "未找到布匹", "window", 10, 100,
                        "red", "false");
                }
                else
                {
                    //色差检测
                    //boxDistance表示两个框间距
                    hv_boxDistance = ((hv_Width - (hv_boxNumber * hv_boxWidth)) - (hv_boxBenginX * 2)) / (hv_boxNumber - 1);
                    //，boxBenginY框起始y坐标
                    hv_boxBenginY = (hv_Height - hv_boxHeight) / 2;
                    hv_tupleDeviationL = new HTuple();
                    hv_tupleDeviationA = new HTuple();
                    hv_tupleDeviationB = new HTuple();
                    ho_Boxs.Dispose();
                    HOperatorSet.GenEmptyObj(out ho_Boxs);
                    for (hv_i = 0; hv_i.Continue(hv_boxNumber - 1, 1); hv_i = hv_i.TupleAdd(1))
                    {
                        ho_Rectangle.Dispose();
                        HOperatorSet.GenRectangle1(out ho_Rectangle, hv_boxBenginY, hv_boxBenginX + (hv_i * (hv_boxWidth + hv_boxDistance)),
                            hv_boxBenginY + hv_boxHeight, (hv_boxBenginX + (hv_i * (hv_boxWidth + hv_boxDistance))) + hv_boxWidth);
                        OTemp[SP_O] = ho_Boxs.CopyObj(1, -1);
                        SP_O++;
                        ho_Boxs.Dispose();
                        HOperatorSet.Union2(OTemp[SP_O - 1], ho_Rectangle, out ho_Boxs);
                        OTemp[SP_O - 1].Dispose();
                        SP_O = 0;
                        ho_ImageReduced.Dispose();
                        HOperatorSet.ReduceDomain(ho_Image, ho_Rectangle, out ho_ImageReduced);
                        if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            HOperatorSet.InitComputeDevice(hv_DeviceHandle, "median_image");
                            HOperatorSet.ActivateComputeDevice(hv_DeviceHandle);
                        }
                        ho_ImageMedian.Dispose();
                        HOperatorSet.MedianImage(ho_ImageReduced, out ho_ImageMedian, "circle",
                            hv_medianKernal * 0.5, "mirrored");
                        if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                            0))) != 0)
                        {
                            HOperatorSet.DeactivateComputeDevice(hv_DeviceHandle);
                        }
                        ho_Region1.Dispose();
                        HOperatorSet.VarThreshold(ho_ImageMedian, out ho_Region1, 25, 25, 0.2,
                            2, "equal");
                        ho_ImageMedianReduced.Dispose();
                        HOperatorSet.ReduceDomain(ho_ImageMedian, ho_Region1, out ho_ImageMedianReduced
                            );
                        if ((int)(new HTuple(hv_hasTransFormRGB.TupleEqual(0))) != 0)
                        {
                            ho_ImageR.Dispose();
                            ho_ImageG.Dispose();
                            ho_ImageB.Dispose();
                            HOperatorSet.Decompose3(ho_ImageMedianReduced, out ho_ImageR, out ho_ImageG,
                                out ho_ImageB);
                            if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                HOperatorSet.InitComputeDevice(hv_DeviceHandle, "trans_from_rgb");
                                HOperatorSet.ActivateComputeDevice(hv_DeviceHandle);
                            }
                            OTemp[SP_O] = ho_ImageB.CopyObj(1, -1);
                            SP_O++;
                            ho_ImageL.Dispose();
                            ho_ImageA.Dispose();
                            ho_ImageB.Dispose();
                            HOperatorSet.TransFromRgb(ho_ImageR, ho_ImageG, OTemp[SP_O - 1], out ho_ImageL,
                                out ho_ImageA, out ho_ImageB, "cielab");
                            OTemp[SP_O - 1].Dispose();
                            SP_O = 0;
                            if ((int)(new HTuple((new HTuple(hv_DeviceHandle.TupleLength())).TupleGreater(
                                0))) != 0)
                            {
                                HOperatorSet.DeactivateComputeDevice(hv_DeviceHandle);
                            }
                        }
                        else
                        {
                            ho_ImageL.Dispose();
                            HOperatorSet.ReduceDomain(ho_ImageResult1, ho_Rectangle, out ho_ImageL
                                );
                            ho_ImageA.Dispose();
                            HOperatorSet.ReduceDomain(ho_ImageResult2, ho_Rectangle, out ho_ImageA
                                );
                            ho_ImageB.Dispose();
                            HOperatorSet.ReduceDomain(ho_ImageResult3, ho_Rectangle, out ho_ImageB
                                );
                        }
                        HOperatorSet.Intensity(ho_Rectangle, ho_ImageL, out hv_MeanL, out hv_DeviationL);
                        HOperatorSet.Intensity(ho_Rectangle, ho_ImageA, out hv_MeanA, out hv_DeviationA);
                        HOperatorSet.Intensity(ho_Rectangle, ho_ImageB, out hv_MeanB, out hv_DeviationB);
                        hv_standardTupleL[hv_i] = hv_MeanL;
                        hv_standardTupleA[hv_i] = hv_MeanA;
                        hv_standardTupleB[hv_i] = hv_MeanB;
                        hv_tupleDeviationL[hv_i] = hv_DeviationL;
                        hv_tupleDeviationA[hv_i] = hv_DeviationA;
                        hv_tupleDeviationB[hv_i] = hv_DeviationB;
                    }

                    HOperatorSet.TupleSort(hv_standardTupleL, out hv_standardTupleL1);
                    HOperatorSet.TupleSort(hv_standardTupleA, out hv_standardTupleA1);
                    HOperatorSet.TupleSort(hv_standardTupleB, out hv_standardTupleB1);

                    if ((int)(new HTuple(hv_boxNumber.TupleGreater(2))) != 0)
                    {
                        hv_totalL = 0;
                        hv_totalA = 0;
                        hv_totalB = 0;
                        for (hv_k = 1; hv_k.Continue(hv_boxNumber - 2, 1); hv_k = hv_k.TupleAdd(1))
                        {
                            hv_totalL = hv_totalL + (hv_standardTupleL1.TupleSelect(hv_k));
                            hv_totalA = hv_totalA + (hv_standardTupleA1.TupleSelect(hv_k));
                            hv_totalB = hv_totalB + (hv_standardTupleB1.TupleSelect(hv_k));
                        }
                        hv_standardL = hv_totalL / (hv_boxNumber - 2);
                        hv_standardA = hv_totalA / (hv_boxNumber - 2);
                        hv_standardB = hv_totalB / (hv_boxNumber - 2);
                    }
                    else
                    {
                        hv_standardL = hv_standardTupleL1[0];
                        hv_standardA = hv_standardTupleA1[0];
                        hv_standardB = hv_standardTupleB1[0];
                    }

                    HOperatorSet.SetColor(hv_ExpDefaultWinHandle, "green");
                    HOperatorSet.SetDraw(hv_ExpDefaultWinHandle, "margin");
                    HOperatorSet.SetLineWidth(hv_ExpDefaultWinHandle, 2);
                    HOperatorSet.DispObj(ho_Boxs, hv_ExpDefaultWinHandle);
                    disp_message(hv_ExpDefaultWinHandle, "标准色差获取成功", "window",
                        10, 100, "red", "false");
                }
            }

            ho_GrayImage.Dispose();
            ho_Rectangle.Dispose();
            ho_Image1.Dispose();
            ho_Image2.Dispose();
            ho_Image3.Dispose();
            ho_Regions1.Dispose();
            ho_RegionErosion1.Dispose();
            ho_ConnectedRegions1.Dispose();
            ho_SelectedRegions1.Dispose();
            ho_ImageResult1.Dispose();
            ho_ImageResult2.Dispose();
            ho_ImageResult3.Dispose();
            ho_SelectedRegions.Dispose();
            ho_Boxs.Dispose();
            ho_ImageReduced.Dispose();
            ho_ImageMedian.Dispose();
            ho_Region1.Dispose();
            ho_ImageMedianReduced.Dispose();
            ho_ImageR.Dispose();
            ho_ImageG.Dispose();
            ho_ImageB.Dispose();
            ho_ImageL.Dispose();
            ho_ImageA.Dispose();

            return;
        }

        public void get_defect_aberration_fun(HObject ho_Image, HTuple hv_WindowHandle,
            HTuple hv_inPar, out HTuple hv_result, out HTuple hv_defectNumber, out HTuple hv_tupleDefectX,
            out HTuple hv_tupleDefectY, out HTuple hv_tupleDefectRadius, out HTuple hv_L,
            out HTuple hv_A, out HTuple hv_B)
        {



            // Local control variables 

            HTuple hv_boxNumber, hv_boxWidth, hv_boxHeight;
            HTuple hv_boxBenginX, hv_medianKernal, hv_dynThresh, hv_defectArea;
            HTuple hv_standardTupleL, hv_standardTupleA, hv_standardTupleB;
            HTuple hv_clothAberrationGrad1, hv_clothAberrationGrad2;
            HTuple hv_clothAberrationGrad3, hv_clothAberrationGrad4;
            HTuple hv_thresh = new HTuple(), hv_defectWidth = new HTuple();
            HTuple hv_defectHeight = new HTuple(), hv_clothAberration;

            // Initialize local and output iconic variables 

            hv_boxNumber = hv_inPar[0];
            hv_boxWidth = hv_inPar[1];
            hv_boxHeight = hv_inPar[2];
            hv_boxBenginX = hv_inPar[3];
            hv_medianKernal = hv_inPar[4];
            hv_dynThresh = hv_inPar[5];
            hv_defectArea = hv_inPar[6];
            hv_standardTupleL = hv_inPar[7];
            hv_standardTupleA = hv_inPar[8];
            hv_standardTupleB = hv_inPar[9];
            hv_clothAberrationGrad1 = hv_inPar[10];
            hv_clothAberrationGrad2 = hv_inPar[11];
            hv_clothAberrationGrad3 = hv_inPar[12];
            hv_clothAberrationGrad4 = hv_inPar[13];
            get_defect_aberration(ho_Image, hv_WindowHandle, hv_boxNumber, hv_boxWidth, hv_boxHeight,
                hv_boxBenginX, hv_medianKernal, hv_thresh, hv_dynThresh, hv_defectWidth,
                hv_defectHeight, hv_defectArea, hv_standardTupleL, hv_standardTupleA, hv_standardTupleB,
                hv_clothAberrationGrad1, hv_clothAberrationGrad2, hv_clothAberrationGrad3,
                hv_clothAberrationGrad4, out hv_result, out hv_defectNumber, out hv_tupleDefectX,
                out hv_tupleDefectY, out hv_tupleDefectRadius, out hv_clothAberration, out hv_L,
                out hv_A, out hv_B);


            return;
        }

        public void estimate_background_illumination(HObject ho_Image, out HObject ho_IlluminationImage)
        {


            // Local iconic variables 

            HObject ho_ImageFFT, ho_ImageGauss, ho_ImageConvol;


            // Local control variables 

            HTuple hv_Width, hv_Height;

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_IlluminationImage);
            HOperatorSet.GenEmptyObj(out ho_ImageFFT);
            HOperatorSet.GenEmptyObj(out ho_ImageGauss);
            HOperatorSet.GenEmptyObj(out ho_ImageConvol);

            HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
            ho_ImageFFT.Dispose();
            HOperatorSet.RftGeneric(ho_Image, out ho_ImageFFT, "to_freq", "none", "complex",
                hv_Width);
            ho_ImageGauss.Dispose();
            HOperatorSet.GenGaussFilter(out ho_ImageGauss, 50, 50, 0, "n", "rft", hv_Width,
                hv_Height);
            ho_ImageConvol.Dispose();
            HOperatorSet.ConvolFft(ho_ImageFFT, ho_ImageGauss, out ho_ImageConvol);
            ho_IlluminationImage.Dispose();
            HOperatorSet.RftGeneric(ho_ImageConvol, out ho_IlluminationImage, "from_freq",
                "none", "byte", hv_Width);
            ho_ImageFFT.Dispose();
            ho_ImageGauss.Dispose();
            ho_ImageConvol.Dispose();

            return;
        }

        // Main procedure 
        private void action(HObject ho_Image, HTuple Window, out HTuple hv_dE)
        {

            // Local iconic variables 

            HObject ho_DefectRegion, ho_Image1, ho_Image2;


            // Local control variables 

            HTuple hv_boxNumber, hv_boxWidth, hv_boxHeight;
            HTuple hv_boxBenginX, hv_medianKernal, hv_tupleL, hv_tupleA;
            HTuple hv_tupleB, hv_result, hv_clothAberrationGrad1, hv_clothAberrationGrad2;
            HTuple hv_clothAberrationGrad3, hv_clothAberrationGrad4;
            HTuple hv_standardTupleL, hv_standardTupleA, hv_standardTupleB;
            HTuple hv_dynThresh, hv_defectArea, hv_defectNumber, hv_tupleDefectX;
            HTuple hv_tupleDefectY, hv_tupleDefectRadius, hv_clothAberration;
            HTuple hv_WindowHandle = new HTuple(), hv_standardL, hv_standardA;
            HTuple hv_standardB, hv_L, hv_A, hv_B;

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_DefectRegion);
            HOperatorSet.GenEmptyObj(out ho_Image1);
            HOperatorSet.GenEmptyObj(out ho_Image2);

            //框个数
            hv_boxNumber = 6;
            //boxWidth:=200框宽度，boxHeight:=200框高度
            hv_boxWidth = 400;
            hv_boxHeight = 400;
            //boxBenginX框起始X坐标
            hv_boxBenginX = 1000;
            //滤波卷积核大小medianKernal
            hv_medianKernal = 20;
            //六个框的LAB值
            hv_tupleL = new HTuple();
            hv_tupleA = new HTuple();
            hv_tupleB = new HTuple();
            //result检测结果，0表示没有缺陷，1表示未找到布匹，2表示布匹接缝，3表示检测到缺陷
            hv_result = 0;

            hv_clothAberrationGrad1 = 0.5;
            hv_clothAberrationGrad2 = 1.5;
            hv_clothAberrationGrad3 = 3.0;
            hv_clothAberrationGrad4 = 6.0;
            hv_standardTupleL = new HTuple();
            hv_standardTupleA = new HTuple();
            hv_standardTupleB = new HTuple();
            //**************
            //dynThresh缺陷阈值
            //defectArea缺陷面积
            //tupleDefectX缺陷中心X坐标合集
            //tupleDefectY缺陷中心Y坐标合集
            //tupleDefectRadius缺陷半径合集
            //**************
            hv_dynThresh = 15;
            hv_defectArea = 5;
            hv_defectNumber = 0;
            hv_tupleDefectX = new HTuple();
            hv_tupleDefectY = new HTuple();
            hv_tupleDefectRadius = new HTuple();
            hv_clothAberration = 0;
            ho_DefectRegion.Dispose();
            HOperatorSet.GenEmptyObj(out ho_DefectRegion);
            ho_Image1.Dispose();
            HOperatorSet.ReadImage(out ho_Image1, "C:/Users/Administrator/Desktop/新建文件夹 (3)/23.bmp");
            ho_Image2.Dispose();
            HOperatorSet.ReadImage(out ho_Image2, "C:/Users/Administrator/Desktop/新建文件夹 (3)/24.bmp");
            //dev_open_window(...);
            
            get_standard_lab(ho_Image1, 200000, hv_boxNumber, hv_boxWidth, hv_boxHeight, hv_boxBenginX,
                hv_medianKernal, out hv_standardTupleL, out hv_standardTupleA, out hv_standardTupleB,
                out hv_standardL, out hv_standardA, out hv_standardB, out hv_result);

            //boxNumber := inPar[0]
            //boxWidth := inPar[1]
            //boxHeight := inPar[2]
            //boxBenginX := inPar[3]
            //medianKernal := inPar[4]
            //dynThresh := inPar[5]
            //defectArea := inPar[6]
            //standardTupleL := inPar[7]
            //standardTupleA := inPar[8]
            //standardTupleB := inPar[9]
            //clothAberrationGrad1 := inPar[10]
            //clothAberrationGrad2 := inPar[11]
            //clothAberrationGrad3 := inPar[12]
            //clothAberrationGrad4 := inPar[13]
            //get_defect_aberration(ho_Image2, hv_WindowHandle, hv_boxNumber, hv_boxWidth,
            //    hv_boxHeight, hv_boxBenginX, hv_medianKernal, hv_dynThresh, hv_defectArea,
            //    hv_standardTupleL, hv_standardTupleA, hv_standardTupleB, hv_clothAberrationGrad1,
            //    hv_clothAberrationGrad2, hv_clothAberrationGrad3, hv_clothAberrationGrad4,
            //    out hv_result, out hv_defectNumber, out hv_tupleDefectX, out hv_tupleDefectY,
            //    out hv_tupleDefectRadius, out hv_clothAberration, out hv_L, out hv_A, out hv_B);

            //return ()

            //inPar := [boxNumber, boxWidth, boxHeight, boxBenginX, medianKernal, dynThresh, defectArea, standardTupleL, standardTupleA, standardTupleB, clothAberrationGrad1, clothAberrationGrad2, clothAberrationGrad3, clothAberrationGrad4]

            //get_defect_aberration_fun (Image2, WindowHandle, inPar, result1, defectNumber, tupleDefectX, tupleDefectY, tupleDefectRadius, L, A, B)




            hv_dE = 0;

            ho_DefectRegion.Dispose();
            ho_Image1.Dispose();
            ho_Image2.Dispose();

        }



        private void action(HObject ho_Image, out HTuple hv_dE)
        {

            // Local iconic variables 

            HObject ho_DefectRegion;

            // 输入参数：加载检测框参数、色差等级参数、缺陷检测参数；
            // 输出参数：六个检测框的lab值、检测结果（瑕疵位置、大小、数量）

            // Local control variables 

            HTuple hv_boxNumber, hv_boxWidth, hv_boxHeight;
            HTuple hv_boxBenginX, hv_medianKernal, hv_tupleL, hv_tupleA;
            HTuple hv_tupleB, hv_result, hv_dynThresh, hv_defectArea;
            HTuple hv_defectNumber, hv_tupleDefectX, hv_tupleDefectY;
            HTuple hv_tupleDefectRadius, hv_L1, hv_A1, hv_B1, hv_L2;
            HTuple hv_A2, hv_B2, hv_Sqrt;

            // Initialize local and output iconic variables 
            HOperatorSet.GenEmptyObj(out ho_DefectRegion);


            //框个数
            hv_boxNumber = 6;
            //boxWidth:=200框宽度，boxHeight:=200框高度
            hv_boxWidth = 400;
            hv_boxHeight = 400;
            //boxBenginX框起始X坐标
            hv_boxBenginX = 1000;
            //滤波卷积核大小medianKernal
            hv_medianKernal = 20;
            //六个框的LAB值
            hv_tupleL = new HTuple();
            hv_tupleA = new HTuple();
            hv_tupleB = new HTuple();
            //result检测结果，0表示没有缺陷，1表示未找到布匹，2表示布匹接缝，3表示检测到缺陷
            hv_result = 0;

            //**************
            //dynThresh缺陷阈值
            //defectArea缺陷面积
            //tupleDefectX缺陷中心X坐标合集
            //tupleDefectY缺陷中心Y坐标合集
            //tupleDefectRadius缺陷半径合集
            //**************
            hv_dynThresh = 15;
            hv_defectArea = 5;
            hv_defectNumber = 0;
            hv_tupleDefectX = new HTuple();
            hv_tupleDefectY = new HTuple();
            hv_tupleDefectRadius = new HTuple();
            ho_DefectRegion.Dispose();
            HOperatorSet.GenEmptyObj(out ho_DefectRegion);


            HOperatorSet.ReadImage(out ho_Image, "F:/250.bmp");
            ho_DefectRegion.Dispose();



            get_defect_lab(ho_Image, out ho_DefectRegion, hv_boxNumber, hv_boxWidth, hv_boxHeight,
                hv_boxBenginX, hv_medianKernal, hv_dynThresh, hv_defectArea, out hv_result,
                out hv_tupleL, out hv_tupleA, out hv_tupleB, out hv_defectNumber, out hv_tupleDefectX,
                out hv_tupleDefectY, out hv_tupleDefectRadius);



            if (true)
            {
                //
                // if bgetstandard  is true
                // write to ini (clothdetail)

            }


            if (hv_result > 1)
            {

                //calculate  the difference of lab value and standard lab
                //calculate the LAB value of six box；






                hv_L1 = hv_tupleL[0];
                hv_A1 = hv_tupleA[0];
                hv_B1 = hv_tupleB[0];
                hv_L2 = hv_tupleL[1];
                hv_A2 = hv_tupleA[1];
                hv_B2 = hv_tupleB[1];
                HOperatorSet.TupleSqrt((((hv_L2 - hv_L1) * (hv_L2 - hv_L1)) + ((hv_A2 - hv_A1) * (hv_A2 - hv_A1))) + ((hv_B2 - hv_B1) * (hv_B2 - hv_B1)),
                    out hv_Sqrt);


                hv_dE = hv_Sqrt;


            }
            else
                hv_dE = 0;
            HOperatorSet.DispObj(ho_Image, hv_ExpDefaultWinHandle);

            ho_DefectRegion.Dispose();
            ho_Image.Dispose();

        }


        public void InitHalcon()
        {
            // Default settings used in HDevelop 
            HOperatorSet.SetSystem("do_low_error", "true");
        }

        public double RunHalcon(HTuple Window, HObject ho_Image, HObject ho_Rectangle, HObject ho_Rectangle1)
        {
            hv_ExpDefaultWinHandle = Window;
            HTuple hv_Colordiff;
            action(ho_Image, out hv_Colordiff);
            // action( ho_Image, ho_Rectangle, ho_Rectangle1,out hv_Colordiff);
            return hv_Colordiff;
        }

    }
}

